/*------------------------ CeCILL-B HEADER ------------------------------------
    Copyright ANSSI (2013)
    Contributors : Ryad BENADJILA [ryad.benadjila@ssi.gouv.fr] and
    Thomas CALDERON [thomas.calderon@ssi.gouv.fr]

    This software is a computer program whose purpose is to implement
    a PKCS#11 proxy as well as a PKCS#11 filter with security features
    in mind. The project source tree is subdivided in six parts.
    There are five main parts:
      1] OCaml/C PKCS#11 bindings (using OCaml IDL).
      2] XDR RPC generators (to be used with ocamlrpcgen and/or rpcgen).
      3] A PKCS#11 RPC server (daemon) in OCaml using a Netplex RPC basis.
      4] A PKCS#11 filtering module used as a backend to the RPC server.
      5] A PKCS#11 client module that comes as a dynamic library offering
         the PKCS#11 API to the software.
    There is one "optional" part:
      6] Tests in C and OCaml to be used with client module 5] or with the
         bindings 1]

    Here is a big picture of how the PKCS#11 proxy works:

 ----------------------   --------  socket (TCP or Unix)  --------------------
| 3] PKCS#11 RPC server|-|2] RPC  |<+++++++++++++++++++> | 5] Client library  |
 ----------------------  |  Layer | [SSL/TLS optional]   |  --------          |
           |              --------                       | |2] RPC  | PKCS#11 |
 ----------------------                                  | |  Layer |functions|
| 4] PKCS#11 filter    |                                 |  --------          |
 ----------------------                                   --------------------
           |                                                        |
 ----------------------                                             |
| 1] PKCS#11 OCaml     |                                  { PKCS#11 INTERFACE }
|       bindings       |                                            |
 ----------------------                                       APPLICATION
           |
           |
 { PKCS#11 INTERFACE }
           |
 REAL PKCS#11 MIDDLEWARE
    (shared library)

    This software is governed by the CeCILL-B license under French law and
    abiding by the rules of distribution of free software.  You can  use,
    modify and/ or redistribute the software under the terms of the CeCILL-B
    license as circulated by CEA, CNRS and INRIA at the following URL
    "http://www.cecill.info".

    As a counterpart to the access to the source code and  rights to copy,
    modify and redistribute granted by the license, users are provided only
    with a limited warranty  and the software's author,  the holder of the
    economic rights,  and the successive licensors  have only  limited
    liability.

    In this respect, the user's attention is drawn to the risks associated
    with loading,  using,  modifying and/or developing or reproducing the
    software by the user in light of its specific status of free software,
    that may mean  that it is complicated to manipulate,  and  that  also
    therefore means  that it is reserved for developers  and  experienced
    professionals having in-depth computer knowledge. Users are therefore
    encouraged to load and test the software's suitability as regards their
    requirements in conditions enabling the security of their systems and/or
    data to be ensured and,  more generally, to use and operate it in the
    same conditions as regards security.

    The fact that you are presently reading this means that you have had
    knowledge of the CeCILL-B license and that you accept its terms.

    The current source code is part of the bindings 1] source tree:
 ----------------------
| 1] PKCS#11 OCaml     |
|       bindings       |
 ----------------------
           |
           |
 { PKCS#11 INTERFACE }
           |
  REAL PKCS#11 MIDDLEWARE
     (shared library)

    Project: PKCS#11 Filtering Proxy
    File:    src/bindings-pkcs11/pkcs11.idl

-------------------------- CeCILL-B HEADER ----------------------------------*/
#define CRYPTOKI_VERSION_MAJOR		2
#define CRYPTOKI_VERSION_MINOR		20
#define CRYPTOKI_VERSION_AMENDMENT	3

quote(H, "#include <stdint.h>");
quote(H, "#include <stdlib.h>");
quote(H, "#include <stdio.h>");
quote(H, "");

typedef[nativeint]
unsigned long ck_flags_t;

struct ck_version {
  unsigned char major;
  unsigned char minor;
};

quote(H,
      "#define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n");
quote(H, "");

quote(H, "#ifdef __FreeBSD__");
quote(H, "/* Needed on FreeBSD for endianess conversion functions */");
quote(H, "#include <sys/endian.h>");
quote(H, "#endif");
quote(H, "");

quote(H, "#ifdef __APPLE__");
quote(H, "/* Needed on Mac OS X for endianess conversion functions */");
quote(H, "#include <libkern/OSByteOrder.h>");
quote(H, "");
quote(H, "#define htobe16(x) OSSwapHostToBigInt16(x)");
quote(H, "#define htole16(x) OSSwapHostToLittleInt16(x)");
quote(H, "#define be16toh(x) OSSwapBigToHostInt16(x)");
quote(H, "#define le16toh(x) OSSwapLittleToHostInt16(x)");
quote(H, "");
quote(H, "#define htobe32(x) OSSwapHostToBigInt32(x)");
quote(H, "#define htole32(x) OSSwapHostToLittleInt32(x)");
quote(H, "#define be32toh(x) OSSwapBigToHostInt32(x)");
quote(H, "#define le32toh(x) OSSwapLittleToHostInt32(x)");
quote(H, "");
quote(H, "#define htobe64(x) OSSwapHostToBigInt64(x)");
quote(H, "#define htole64(x) OSSwapHostToLittleInt64(x)");
quote(H, "#define be64toh(x) OSSwapBigToHostInt64(x)");
quote(H, "#define le64toh(x) OSSwapLittleToHostInt64(x)");
quote(H, "#endif");
quote(H, "");

quote(H, "#ifdef CUSTOM_ALLOC");
quote(H, "void* custom_malloc(size_t size);");
quote(H, "void custom_free(void** to_free);");
quote(H, "");
quote(H, "/* Custom malloc to fail on malloc error */");
quote(H, "void* custom_malloc(size_t size){");
quote(H, "  void* returned_pointer = (void*)malloc(size);");
quote(H, "  if(returned_pointer == NULL){");
quote(H, "#ifdef DEBUG");
quote(H, "    printf (\"malloc error: NULL pointer returned! We exit\\n\");");
quote(H, "#endif");
quote(H, "    exit(-1);");
quote(H, "  }");
quote(H, "  return returned_pointer;");
quote(H, "}");
quote(H, "/* Custom free to force NULL on variables */");
quote(H, "void custom_free(void** to_free){");
quote(H, "  if(*to_free == NULL){");
quote(H, "#ifdef DEBUG");
quote(H,
      "    printf (\"warning: trying to free a NULL pointer! Ignoring ...\\n\");");
quote(H, "#endif");
quote(H, "    return;");
quote(H, "  }");
quote(H, "  free(*to_free);");
quote(H, "  *to_free = NULL;");
quote(H, "  return;");
quote(H, "}");
quote(H, "#else");
quote(H, "extern void* custom_malloc(size_t size);");
quote(H, "extern void custom_free(void** to_free);");
quote(H, "#endif");

quote(H,
      "/* To handle nativeint versus int64 for native bindings versus RPC ocaml client */");
quote(H, "#ifdef CAMLRPC");
quote(H, "#define custom_copy_int(input) copy_int64((input))");
quote(H, "#define custom_int_val(input) Int64_val((input))");
quote(H, "#else");
quote(H, "#define custom_copy_int(input) copy_nativeint((input))");
quote(H, "#define custom_int_val(input) Nativeint_val((input))");
quote(H, "#endif");

quote(H, "#define LITTLE_ENDIAN_64 1");
quote(H, "#define LITTLE_ENDIAN_32 2");
quote(H, "#define BIG_ENDIAN_64 3");
quote(H, "#define BIG_ENDIAN_32 4");
quote(H, "#define UNSUPPORTED_ARCHITECTURE 5");
quote(H, "#define NOT_INITIALIZED 6");

quote(mli, "val lITTLE_ENDIAN_64  : nativeint");
quote(mli, "val lITTLE_ENDIAN_32  : nativeint");
quote(mli, "val bIG_ENDIAN_64  : nativeint");
quote(mli, "val bIG_ENDIAN_32  : nativeint");
quote(mli, "val uNSUPPORTED_ARCHITECTURE  : nativeint");
quote(mli, "val nOT_INITIALIZED  : nativeint");

quote(ml, "let lITTLE_ENDIAN_64  = 1n");
quote(ml, "let lITTLE_ENDIAN_32  = 2n");
quote(ml, "let bIG_ENDIAN_64  = 3n");
quote(ml, "let bIG_ENDIAN_32  = 4n");
quote(ml, "let uNSUPPORTED_ARCHITECTURE  = 5n");
quote(ml, "let nOT_INITIALIZED  = 6n");

quote(mli, "val match_arch_value : nativeint -> string\n");
quote(ml, "let match_arch_value a = match a with");
quote(ml, "   1n -> \"LITTLE_ENDIAN_64\"");
quote(ml, " | 2n -> \"LITTLE_ENDIAN_32\"");
quote(ml, " | 3n -> \"BIG_ENDIAN_64\"");
quote(ml, " | 4n -> \"BIG_ENDIAN_32\"");
quote(ml, " | 5n -> \"UNSUPPORTED_ARCHITECTURE\"");
quote(ml, " | 6n -> \"NOT_INITIALIZED\"");
quote(ml, " | _  -> \"UNKNOWN_ERROR\"");


quote(H, "");
quote(H, "#ifdef SERVER_ROLE");
quote(H, "/* variable used to avoid multiple calls to C_LoadModule */");
quote(H, "unsigned long module_loaded = NOT_INITIALIZED;");
quote(H, "/* variable used to detect architecture */");
quote(H, "unsigned long peer_arch = NOT_INITIALIZED;");
quote(H, "#else");
quote(H, "unsigned long peer_arch;");
quote(H, "#endif");
quote(H, "unsigned long my_arch;");
quote(H, "");

struct ck_info {
  struct ck_version cryptoki_version;
  unsigned char manufacturer_id[32];
  ck_flags_t flags;
  unsigned char library_description[32];
  struct ck_version library_version;
};

typedef[nativeint]
unsigned long ck_notification_t;

#define CKN_SURRENDER	(0UL)

/* The following notification is new for PKCS #11 v2.20 amendment 3 */
#define CKN_OTP_CHANGED     (1UL)

typedef[nativeint]
unsigned long ck_slot_id_t;

struct ck_slot_info {
  unsigned char slot_description[64];
  unsigned char manufacturer_id[32];
  ck_flags_t flags;
  struct ck_version hardware_version;
  struct ck_version firmware_version;
};

#define CKF_TOKEN_PRESENT	(1UL << 0)
#define CKF_REMOVABLE_DEVICE	(1UL << 1)
#define CKF_HW_SLOT		(1UL << 2)
#define CKF_ARRAY_ATTRIBUTE	(1UL << 30)

struct ck_token_info {
  unsigned char label[32];
  unsigned char manufacturer_id[32];
  unsigned char model[16];
  unsigned char serial_number[16];
  ck_flags_t flags;
  [nativeint] unsigned long max_session_count;
  [nativeint] unsigned long session_count;
  [nativeint] unsigned long max_rw_session_count;
  [nativeint] unsigned long rw_session_count;
  [nativeint] unsigned long max_pin_len;
  [nativeint] unsigned long min_pin_len;
  [nativeint] unsigned long total_public_memory;
  [nativeint] unsigned long free_public_memory;
  [nativeint] unsigned long total_private_memory;
  [nativeint] unsigned long free_private_memory;
  struct ck_version hardware_version;
  struct ck_version firmware_version;
  unsigned char utc_time[16];
};

#define CKF_RNG					(1UL << 0)
#define CKF_WRITE_PROTECTED			(1UL << 1)
#define CKF_LOGIN_REQUIRED			(1UL << 2)
#define CKF_USER_PIN_INITIALIZED		(1UL << 3)
#define CKF_RESTORE_KEY_NOT_NEEDED		(1UL << 5)
#define CKF_CLOCK_ON_TOKEN			(1UL << 6)
#define CKF_PROTECTED_AUTHENTICATION_PATH	(1UL << 8)
#define CKF_DUAL_CRYPTO_OPERATIONS		(1UL << 9)
#define CKF_TOKEN_INITIALIZED			(1UL << 10)
#define CKF_SECONDARY_AUTHENTICATION		(1UL << 11)
#define CKF_USER_PIN_COUNT_LOW			(1UL << 16)
#define CKF_USER_PIN_FINAL_TRY			(1UL << 17)
#define CKF_USER_PIN_LOCKED			(1UL << 18)
#define CKF_USER_PIN_TO_BE_CHANGED		(1UL << 19)
#define CKF_SO_PIN_COUNT_LOW			(1UL << 20)
#define CKF_SO_PIN_FINAL_TRY			(1UL << 21)
#define CKF_SO_PIN_LOCKED			(1UL << 22)
#define CKF_SO_PIN_TO_BE_CHANGED		(1UL << 23)

#define CK_UNAVAILABLE_INFORMATION	((unsigned long)-1L)
#define CK_EFFECTIVELY_INFINITE		(0UL)

typedef[nativeint]
unsigned long ck_session_handle_t;

#define CK_INVALID_HANDLE	(0UL)

typedef[nativeint]
unsigned long ck_user_type_t;

#define CKU_SO			(0UL)
#define CKU_USER		(1UL)
#define CKU_CONTEXT_SPECIFIC	(2UL)

typedef[nativeint]
unsigned long ck_state_t;

#define CKS_RO_PUBLIC_SESSION	(0UL)
#define CKS_RO_USER_FUNCTIONS	(1UL)
#define CKS_RW_PUBLIC_SESSION	(2UL)
#define CKS_RW_USER_FUNCTIONS	(3UL)
#define CKS_RW_SO_FUNCTIONS	(4UL)

struct ck_session_info {
  ck_slot_id_t slot_id;
  ck_state_t state;
  ck_flags_t flags;
  [nativeint] unsigned long device_error;
};

#define CKF_RW_SESSION		(1UL << 1)
#define CKF_SERIAL_SESSION	(1UL << 2)

typedef[nativeint]
unsigned long ck_object_handle_t;

typedef[nativeint]
unsigned long ck_object_class_t;

#define CKO_DATA		(0UL)
#define CKO_CERTIFICATE		(1UL)
#define CKO_PUBLIC_KEY		(2UL)
#define CKO_PRIVATE_KEY		(3UL)
#define CKO_SECRET_KEY		(4UL)
#define CKO_HW_FEATURE		(5UL)
#define CKO_DOMAIN_PARAMETERS	(6UL)
#define CKO_MECHANISM		(7UL)
/* CKO_OTP_KEY is new for PKCS #11 v2.20 amendment 1 */
#define CKO_OTP_KEY             (8UL)
#define CKO_VENDOR_DEFINED	((unsigned long) (1UL << 31))

typedef[nativeint]
unsigned long ck_hw_feature_type_t;

#define CKH_MONOTONIC_COUNTER	(1UL)
#define CKH_CLOCK		(2UL)
#define CKH_USER_INTERFACE	(3UL)
#define CKH_VENDOR_DEFINED	((unsigned long) (1UL << 31))

typedef[nativeint]
unsigned long ck_key_type_t;

#define CKK_RSA			(0UL)
#define CKK_DSA			(1UL)
#define CKK_DH			(2UL)
#define CKK_ECDSA		(3UL)
#define CKK_EC			(3UL)
#define CKK_X9_42_DH		(4UL)
#define CKK_KEA			(5UL)
#define CKK_GENERIC_SECRET	(0x10UL)
#define CKK_RC2			(0x11UL)
#define CKK_RC4			(0x12UL)
#define CKK_DES			(0x13UL)
#define CKK_DES2		(0x14UL)
#define CKK_DES3		(0x15UL)
#define CKK_CAST		(0x16UL)
#define CKK_CAST3		(0x17UL)
#define CKK_CAST128		(0x18UL)
#define CKK_RC5			(0x19UL)
#define CKK_IDEA		(0x1aUL)
#define CKK_SKIPJACK		(0x1bUL)
#define CKK_BATON		(0x1cUL)
#define CKK_JUNIPER		(0x1dUL)
#define CKK_CDMF		(0x1eUL)
#define CKK_AES			(0x1fUL)
#define CKK_BLOWFISH		(0x20UL)
#define CKK_TWOFISH		(0x21UL)
/* SecurID, HOTP, and ACTI are new for PKCS #11 v2.20 amendment 1 */
#define CKK_SECURID         	(0x22UL)
#define CKK_HOTP            	(0x23UL)
#define CKK_ACTI            	(0x24UL)
/* Camellia is new for PKCS #11 v2.20 amendment 3 */
#define CKK_CAMELLIA            (0x25UL)
/* ARIA is new for PKCS #11 v2.20 amendment 3 */
#define CKK_ARIA                (0x26UL)
#define CKK_VENDOR_DEFINED	((unsigned long) (1UL << 31))

typedef[nativeint]
unsigned long ck_certificate_type_t;

#define CKC_X_509		(0UL)
#define CKC_X_509_ATTR_CERT	(1UL)
#define CKC_WTLS		(2UL)
#define CKC_VENDOR_DEFINED	((unsigned long) (1UL << 31))

typedef[nativeint]
unsigned long ck_attribute_type_t;

/* The following OTP-related defines are new for PKCS #11 v2.20 amendment 1
   and relates to the CKA_OTP_FORMAT attribute */
#define CK_OTP_FORMAT_DECIMAL      (0UL)
#define CK_OTP_FORMAT_HEXADECIMAL  (1UL)
#define CK_OTP_FORMAT_ALPHANUMERIC (2UL)
#define CK_OTP_FORMAT_BINARY       (3UL)

/* The following OTP-related defines are new for PKCS #11 v2.20 amendment 1
   and relates to the CKA_OTP_..._REQUIREMENT attributes */
#define CK_OTP_PARAM_IGNORED       (0UL)
#define CK_OTP_PARAM_OPTIONAL      (1UL)
#define CK_OTP_PARAM_MANDATORY     (2UL)

#define CKA_CLASS			(0UL)
#define CKA_TOKEN			(1UL)
#define CKA_PRIVATE			(2UL)
#define CKA_LABEL			(3UL)
#define CKA_APPLICATION			(0x10UL)
#define CKA_VALUE			(0x11UL)
#define CKA_OBJECT_ID			(0x12UL)
#define CKA_CERTIFICATE_TYPE		(0x80UL)
#define CKA_ISSUER			(0x81UL)
#define CKA_SERIAL_NUMBER		(0x82UL)
#define CKA_AC_ISSUER			(0x83UL)
#define CKA_OWNER			(0x84UL)
#define CKA_ATTR_TYPES			(0x85UL)
#define CKA_TRUSTED			(0x86UL)
#define CKA_CERTIFICATE_CATEGORY	(0x87UL)
#define CKA_JAVA_MIDP_SECURITY_DOMAIN	(0x88UL)
#define CKA_URL				(0x89UL)
#define CKA_HASH_OF_SUBJECT_PUBLIC_KEY	(0x8aUL)
#define CKA_HASH_OF_ISSUER_PUBLIC_KEY	(0x8bUL)
#define CKA_CHECK_VALUE			(0x90UL)
#define CKA_KEY_TYPE			(0x100UL)
#define CKA_SUBJECT			(0x101UL)
#define CKA_ID				(0x102UL)
#define CKA_SENSITIVE			(0x103UL)
#define CKA_ENCRYPT			(0x104UL)
#define CKA_DECRYPT			(0x105UL)
#define CKA_WRAP			(0x106UL)
#define CKA_UNWRAP			(0x107UL)
#define CKA_SIGN			(0x108UL)
#define CKA_SIGN_RECOVER		(0x109UL)
#define CKA_VERIFY			(0x10aUL)
#define CKA_VERIFY_RECOVER		(0x10bUL)
#define CKA_DERIVE			(0x10cUL)
#define CKA_START_DATE			(0x110UL)
#define CKA_END_DATE			(0x111UL)
#define CKA_MODULUS			(0x120UL)
#define CKA_MODULUS_BITS		(0x121UL)
#define CKA_PUBLIC_EXPONENT		(0x122UL)
#define CKA_PRIVATE_EXPONENT		(0x123UL)
#define CKA_PRIME_1			(0x124UL)
#define CKA_PRIME_2			(0x125UL)
#define CKA_EXPONENT_1			(0x126UL)
#define CKA_EXPONENT_2			(0x127UL)
#define CKA_COEFFICIENT			(0x128UL)
#define CKA_PRIME			(0x130UL)
#define CKA_SUBPRIME			(0x131UL)
#define CKA_BASE			(0x132UL)
#define CKA_PRIME_BITS			(0x133UL)
#define CKA_SUB_PRIME_BITS		(0x134UL)
#define CKA_VALUE_BITS			(0x160UL)
#define CKA_VALUE_LEN			(0x161UL)
#define CKA_EXTRACTABLE			(0x162UL)
#define CKA_LOCAL			(0x163UL)
#define CKA_NEVER_EXTRACTABLE		(0x164UL)
#define CKA_ALWAYS_SENSITIVE		(0x165UL)
#define CKA_KEY_GEN_MECHANISM		(0x166UL)
#define CKA_MODIFIABLE			(0x170UL)
#define CKA_ECDSA_PARAMS		(0x180UL)
#define CKA_EC_PARAMS			(0x180UL)
#define CKA_EC_POINT			(0x181UL)
#define CKA_SECONDARY_AUTH		(0x200UL)
#define CKA_AUTH_PIN_FLAGS		(0x201UL)
#define CKA_ALWAYS_AUTHENTICATE		(0x202UL)
#define CKA_WRAP_WITH_TRUSTED		(0x210UL)
#define CKA_WRAP_TEMPLATE		(CKF_ARRAY_ATTRIBUTE | 0x211UL)
#define CKA_UNWRAP_TEMPLATE		(CKF_ARRAY_ATTRIBUTE | 0x212UL)
/* CKA_OTP... atttributes are new for PKCS #11 v2.20 amendment 3. */
#define CKA_OTP_FORMAT                  (0x220UL)
#define CKA_OTP_LENGTH                  (0x221UL)
#define CKA_OTP_TIME_INTERVAL           (0x222UL)
#define CKA_OTP_USER_FRIENDLY_MODE      (0x223UL)
#define CKA_OTP_CHALLENGE_REQUIREMENT   (0x224UL)
#define CKA_OTP_TIME_REQUIREMENT        (0x225UL)
#define CKA_OTP_COUNTER_REQUIREMENT     (0x226UL)
#define CKA_OTP_PIN_REQUIREMENT         (0x227UL)
#define CKA_OTP_COUNTER                 (0x22EUL)
#define CKA_OTP_TIME                    (0x22FUL)
#define CKA_OTP_USER_IDENTIFIER         (0x22AUL)
#define CKA_OTP_SERVICE_IDENTIFIER      (0x22BUL)
#define CKA_OTP_SERVICE_LOGO            (0x22CUL)
#define CKA_OTP_SERVICE_LOGO_TYPE       (0x22DUL)

#define CKA_HW_FEATURE_TYPE		(0x300UL)
#define CKA_RESET_ON_INIT		(0x301UL)
#define CKA_HAS_RESET			(0x302UL)
#define CKA_PIXEL_X			(0x400UL)
#define CKA_PIXEL_Y			(0x401UL)
#define CKA_RESOLUTION			(0x402UL)
#define CKA_CHAR_ROWS			(0x403UL)
#define CKA_CHAR_COLUMNS		(0x404UL)
#define CKA_COLOR			(0x405UL)
#define CKA_BITS_PER_PIXEL		(0x406UL)
#define CKA_CHAR_SETS			(0x480UL)
#define CKA_ENCODING_METHODS		(0x481UL)
#define CKA_MIME_TYPES			(0x482UL)
#define CKA_MECHANISM_TYPE		(0x500UL)
#define CKA_REQUIRED_CMS_ATTRIBUTES	(0x501UL)
#define CKA_DEFAULT_CMS_ATTRIBUTES	(0x502UL)
#define CKA_SUPPORTED_CMS_ATTRIBUTES	(0x503UL)
#define CKA_ALLOWED_MECHANISMS		(CKF_ARRAY_ATTRIBUTE | 0x600UL)
#define CKA_VENDOR_DEFINED		((unsigned long) (1UL << 31))

struct ck_attribute {
  ck_attribute_type_t type_;
  [size_is(value_len)] char value[];
  [nativeint] unsigned long value_len;
};

struct ck_date {
  unsigned char year[4];
  unsigned char month[2];
  unsigned char day[2];
};

typedef[nativeint]
unsigned long ck_mechanism_type_t;

#define CKM_RSA_PKCS_KEY_PAIR_GEN	(0UL)
#define CKM_RSA_PKCS			(1UL)
#define CKM_RSA_9796			(2UL)
#define CKM_RSA_X_509			(3UL)
#define CKM_MD2_RSA_PKCS		(4UL)
#define CKM_MD5_RSA_PKCS		(5UL)
#define CKM_SHA1_RSA_PKCS		(6UL)
#define CKM_RIPEMD128_RSA_PKCS		(7UL)
#define CKM_RIPEMD160_RSA_PKCS		(8UL)
#define CKM_RSA_PKCS_OAEP		(9UL)
#define CKM_RSA_X9_31_KEY_PAIR_GEN	(0xaUL)
#define CKM_RSA_X9_31			(0xbUL)
#define CKM_SHA1_RSA_X9_31		(0xcUL)
#define CKM_RSA_PKCS_PSS		(0xdUL)
#define CKM_SHA1_RSA_PKCS_PSS		(0xeUL)
#define CKM_DSA_KEY_PAIR_GEN		(0x10UL)
#define	CKM_DSA				(0x11UL)
#define CKM_DSA_SHA1			(0x12UL)
#define CKM_DH_PKCS_KEY_PAIR_GEN	(0x20UL)
#define CKM_DH_PKCS_DERIVE		(0x21UL)
#define	CKM_X9_42_DH_KEY_PAIR_GEN	(0x30UL)
#define CKM_X9_42_DH_DERIVE		(0x31UL)
#define CKM_X9_42_DH_HYBRID_DERIVE	(0x32UL)
#define CKM_X9_42_MQV_DERIVE		(0x33UL)
#define CKM_SHA256_RSA_PKCS		(0x40UL)
#define CKM_SHA384_RSA_PKCS		(0x41UL)
#define CKM_SHA512_RSA_PKCS		(0x42UL)
#define CKM_SHA256_RSA_PKCS_PSS		(0x43UL)
#define CKM_SHA384_RSA_PKCS_PSS		(0x44UL)
#define CKM_SHA512_RSA_PKCS_PSS		(0x45UL)
/* SHA-224 RSA mechanisms are new for PKCS #11 v2.20 amendment 3 */
#define CKM_SHA224_RSA_PKCS             (0x46UL)
#define CKM_SHA224_RSA_PKCS_PSS         (0x47UL)
#define CKM_RC2_KEY_GEN			(0x100UL)
#define CKM_RC2_ECB			(0x101UL)
#define	CKM_RC2_CBC			(0x102UL)
#define	CKM_RC2_MAC			(0x103UL)
#define CKM_RC2_MAC_GENERAL		(0x104UL)
#define CKM_RC2_CBC_PAD			(0x105UL)
#define CKM_RC4_KEY_GEN			(0x110UL)
#define CKM_RC4				(0x111UL)
#define CKM_DES_KEY_GEN			(0x120UL)
#define CKM_DES_ECB			(0x121UL)
#define CKM_DES_CBC			(0x122UL)
#define CKM_DES_MAC			(0x123UL)
#define CKM_DES_MAC_GENERAL		(0x124UL)
#define CKM_DES_CBC_PAD			(0x125UL)
#define CKM_DES2_KEY_GEN		(0x130UL)
#define CKM_DES3_KEY_GEN		(0x131UL)
#define CKM_DES3_ECB			(0x132UL)
#define CKM_DES3_CBC			(0x133UL)
#define CKM_DES3_MAC			(0x134UL)
#define CKM_DES3_MAC_GENERAL		(0x135UL)
#define CKM_DES3_CBC_PAD		(0x136UL)
#define CKM_CDMF_KEY_GEN		(0x140UL)
#define CKM_CDMF_ECB			(0x141UL)
#define CKM_CDMF_CBC			(0x142UL)
#define CKM_CDMF_MAC			(0x143UL)
#define CKM_CDMF_MAC_GENERAL		(0x144UL)
#define CKM_CDMF_CBC_PAD		(0x145UL)
#define CKM_DES_OFB64                   (0x150UL)
#define CKM_DES_OFB8                    (0x151UL)
#define CKM_DES_CFB64                   (0x152UL)
#define CKM_DES_CFB8                    (0x153UL)
#define CKM_MD2				(0x200UL)
#define CKM_MD2_HMAC			(0x201UL)
#define CKM_MD2_HMAC_GENERAL		(0x202UL)
#define CKM_MD5				(0x210UL)
#define CKM_MD5_HMAC			(0x211UL)
#define CKM_MD5_HMAC_GENERAL		(0x212UL)
#define CKM_SHA_1			(0x220UL)
#define CKM_SHA_1_HMAC			(0x221UL)
#define CKM_SHA_1_HMAC_GENERAL		(0x222UL)
#define CKM_RIPEMD128			(0x230UL)
#define CKM_RIPEMD128_HMAC		(0x231UL)
#define CKM_RIPEMD128_HMAC_GENERAL	(0x232UL)
#define CKM_RIPEMD160			(0x240UL)
#define CKM_RIPEMD160_HMAC		(0x241UL)
#define CKM_RIPEMD160_HMAC_GENERAL	(0x242UL)
#define CKM_SHA256			(0x250UL)
#define CKM_SHA256_HMAC			(0x251UL)
#define CKM_SHA256_HMAC_GENERAL		(0x252UL)
/* SHA-224 is new for PKCS #11 v2.20 amendment 3 */
#define CKM_SHA224                      (0x255UL)
#define CKM_SHA224_HMAC                 (0x256UL)
#define CKM_SHA224_HMAC_GENERAL         (0x257UL)
#define CKM_SHA384			(0x260UL)
#define CKM_SHA384_HMAC			(0x261UL)
#define CKM_SHA384_HMAC_GENERAL		(0x262UL)
#define CKM_SHA512			(0x270UL)
#define CKM_SHA512_HMAC			(0x271UL)
#define CKM_SHA512_HMAC_GENERAL		(0x272UL)
/* SecurID is new for PKCS #11 v2.20 amendment 1 */
#define CKM_SECURID_KEY_GEN             (0x280UL)
#define CKM_SECURID                     (0x282UL)
/* HOTP is new for PKCS #11 v2.20 amendment 1 */
#define CKM_HOTP_KEY_GEN     		(0x290UL)
#define CKM_HOTP              		(0x291UL)
/* ACTI is new for PKCS #11 v2.20 amendment 1 */
#define CKM_ACTI              		(0x2A0UL)
#define CKM_ACTI_KEY_GEN      		(0x2A1UL)
#define CKM_CAST_KEY_GEN		(0x300UL)
#define CKM_CAST_ECB			(0x301UL)
#define CKM_CAST_CBC			(0x302UL)
#define CKM_CAST_MAC			(0x303UL)
#define CKM_CAST_MAC_GENERAL		(0x304UL)
#define CKM_CAST_CBC_PAD		(0x305UL)
#define CKM_CAST3_KEY_GEN		(0x310UL)
#define CKM_CAST3_ECB			(0x311UL)
#define CKM_CAST3_CBC			(0x312UL)
#define CKM_CAST3_MAC			(0x313UL)
#define CKM_CAST3_MAC_GENERAL		(0x314UL)
#define CKM_CAST3_CBC_PAD		(0x315UL)
#define CKM_CAST5_KEY_GEN		(0x320UL)
#define CKM_CAST128_KEY_GEN		(0x320UL)
#define CKM_CAST5_ECB			(0x321UL)
#define CKM_CAST128_ECB			(0x321UL)
#define CKM_CAST5_CBC			(0x322UL)
#define CKM_CAST128_CBC			(0x322UL)
#define CKM_CAST5_MAC			(0x323UL)
#define	CKM_CAST128_MAC			(0x323UL)
#define CKM_CAST5_MAC_GENERAL		(0x324UL)
#define CKM_CAST128_MAC_GENERAL		(0x324UL)
#define CKM_CAST5_CBC_PAD		(0x325UL)
#define CKM_CAST128_CBC_PAD		(0x325UL)
#define CKM_RC5_KEY_GEN			(0x330UL)
#define CKM_RC5_ECB			(0x331UL)
#define CKM_RC5_CBC			(0x332UL)
#define CKM_RC5_MAC			(0x333UL)
#define CKM_RC5_MAC_GENERAL		(0x334UL)
#define CKM_RC5_CBC_PAD			(0x335UL)
#define CKM_IDEA_KEY_GEN		(0x340UL)
#define CKM_IDEA_ECB			(0x341UL)
#define	CKM_IDEA_CBC			(0x342UL)
#define CKM_IDEA_MAC			(0x343UL)
#define CKM_IDEA_MAC_GENERAL		(0x344UL)
#define CKM_IDEA_CBC_PAD		(0x345UL)
#define CKM_GENERIC_SECRET_KEY_GEN	(0x350UL)
#define CKM_CONCATENATE_BASE_AND_KEY	(0x360UL)
#define CKM_CONCATENATE_BASE_AND_DATA	(0x362UL)
#define CKM_CONCATENATE_DATA_AND_BASE	(0x363UL)
#define CKM_XOR_BASE_AND_DATA		(0x364UL)
#define CKM_EXTRACT_KEY_FROM_KEY	(0x365UL)
#define CKM_SSL3_PRE_MASTER_KEY_GEN	(0x370UL)
#define CKM_SSL3_MASTER_KEY_DERIVE	(0x371UL)
#define CKM_SSL3_KEY_AND_MAC_DERIVE	(0x372UL)
#define CKM_SSL3_MASTER_KEY_DERIVE_DH	(0x373UL)
#define CKM_TLS_PRE_MASTER_KEY_GEN	(0x374UL)
#define CKM_TLS_MASTER_KEY_DERIVE	(0x375UL)
#define CKM_TLS_KEY_AND_MAC_DERIVE	(0x376UL)
#define CKM_TLS_MASTER_KEY_DERIVE_DH	(0x377UL)
/* CKM_TLS_PRF is new for v2.20 */
#define CKM_TLS_PRF                     (0x378UL)
#define CKM_SSL3_MD5_MAC		(0x380UL)
#define CKM_SSL3_SHA1_MAC		(0x381UL)
#define CKM_MD5_KEY_DERIVATION		(0x390UL)
#define CKM_MD2_KEY_DERIVATION		(0x391UL)
#define CKM_SHA1_KEY_DERIVATION		(0x392UL)
/* CKM_SHA256/384/512 are new for v2.20 */
#define CKM_SHA256_KEY_DERIVATION       (0x393UL)
#define CKM_SHA384_KEY_DERIVATION       (0x394UL)
#define CKM_SHA512_KEY_DERIVATION       (0x395UL)
/* SHA-224 key derivation is new for PKCS #11 v2.20 amendment 3 */
#define CKM_SHA224_KEY_DERIVATION       (0x396UL)
#define CKM_PBE_MD2_DES_CBC		(0x3a0UL)
#define CKM_PBE_MD5_DES_CBC		(0x3a1UL)
#define CKM_PBE_MD5_CAST_CBC		(0x3a2UL)
#define CKM_PBE_MD5_CAST3_CBC		(0x3a3UL)
#define CKM_PBE_MD5_CAST5_CBC		(0x3a4UL)
#define CKM_PBE_MD5_CAST128_CBC		(0x3a4UL)
#define CKM_PBE_SHA1_CAST5_CBC		(0x3a5UL)
#define CKM_PBE_SHA1_CAST128_CBC	(0x3a5UL)
#define CKM_PBE_SHA1_RC4_128		(0x3a6UL)
#define CKM_PBE_SHA1_RC4_40		(0x3a7UL)
#define CKM_PBE_SHA1_DES3_EDE_CBC	(0x3a8UL)
#define CKM_PBE_SHA1_DES2_EDE_CBC	(0x3a9UL)
#define CKM_PBE_SHA1_RC2_128_CBC	(0x3aaUL)
#define CKM_PBE_SHA1_RC2_40_CBC		(0x3abUL)
#define CKM_PKCS5_PBKD2			(0x3b0UL)
#define CKM_PBA_SHA1_WITH_SHA1_HMAC	(0x3c0UL)
/* WTLS mechanisms are new for v2.20 */
#define CKM_WTLS_PRE_MASTER_KEY_GEN        (0x3D0UL)
#define CKM_WTLS_MASTER_KEY_DERIVE         (0x3D1UL)
#define CKM_WTLS_MASTER_KEY_DERIVE_DH_ECC  (0x3D2UL)
#define CKM_WTLS_PRF                       (0x3D3UL)
#define CKM_WTLS_SERVER_KEY_AND_MAC_DERIVE (0x3D4UL)
#define CKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE (0x3D5UL)
#define CKM_KEY_WRAP_LYNKS		(0x400UL)
#define CKM_KEY_WRAP_SET_OAEP		(0x401UL)
/* CKM_CMS_SIG is new for v2.20 */
#define CKM_CMS_SIG                     (0x500UL)
/* CKM_KIP mechanisms are new for PKCS #11 v2.20 amendment 2 */
#define CKM_KIP_DERIVE                   (0x510UL)
#define CKM_KIP_WRAP                     (0x511UL)
#define CKM_KIP_MAC                      (0x512UL)
/* Camellia is new for PKCS #11 v2.20 amendment 3 */
#define CKM_CAMELLIA_KEY_GEN             (0x550UL)
#define CKM_CAMELLIA_ECB                 (0x551UL)
#define CKM_CAMELLIA_CBC                 (0x552UL)
#define CKM_CAMELLIA_MAC                 (0x553UL)
#define CKM_CAMELLIA_MAC_GENERAL         (0x554UL)
#define CKM_CAMELLIA_CBC_PAD             (0x555UL)
#define CKM_CAMELLIA_ECB_ENCRYPT_DATA    (0x556UL)
#define CKM_CAMELLIA_CBC_ENCRYPT_DATA    (0x557UL)
#define CKM_CAMELLIA_CTR                 (0x558UL)
/* ARIA is new for PKCS #11 v2.20 amendment 3 */
#define CKM_ARIA_KEY_GEN                 (0x560UL)
#define CKM_ARIA_ECB                     (0x561UL)
#define CKM_ARIA_CBC                     (0x562UL)
#define CKM_ARIA_MAC                     (0x563UL)
#define CKM_ARIA_MAC_GENERAL             (0x564UL)
#define CKM_ARIA_CBC_PAD                 (0x565UL)
#define CKM_ARIA_ECB_ENCRYPT_DATA        (0x566UL)
#define CKM_ARIA_CBC_ENCRYPT_DATA        (0x567UL)
#define CKM_SKIPJACK_KEY_GEN		(0x1000UL)
#define CKM_SKIPJACK_ECB64		(0x1001UL)
#define CKM_SKIPJACK_CBC64		(0x1002UL)
#define CKM_SKIPJACK_OFB64		(0x1003UL)
#define CKM_SKIPJACK_CFB64		(0x1004UL)
#define CKM_SKIPJACK_CFB32		(0x1005UL)
#define CKM_SKIPJACK_CFB16		(0x1006UL)
#define CKM_SKIPJACK_CFB8		(0x1007UL)
#define CKM_SKIPJACK_WRAP		(0x1008UL)
#define CKM_SKIPJACK_PRIVATE_WRAP	(0x1009UL)
#define CKM_SKIPJACK_RELAYX		(0x100aUL)
#define CKM_KEA_KEY_PAIR_GEN		(0x1010UL)
#define CKM_KEA_KEY_DERIVE		(0x1011UL)
#define CKM_FORTEZZA_TIMESTAMP		(0x1020UL)
#define CKM_BATON_KEY_GEN		(0x1030UL)
#define CKM_BATON_ECB128		(0x1031UL)
#define CKM_BATON_ECB96			(0x1032UL)
#define CKM_BATON_CBC128		(0x1033UL)
#define CKM_BATON_COUNTER		(0x1034UL)
#define CKM_BATON_SHUFFLE		(0x1035UL)
#define CKM_BATON_WRAP			(0x1036UL)
#define CKM_ECDSA_KEY_PAIR_GEN		(0x1040UL)
#define CKM_EC_KEY_PAIR_GEN		(0x1040UL)
#define CKM_ECDSA			(0x1041UL)
#define CKM_ECDSA_SHA1			(0x1042UL)
#define CKM_ECDH1_DERIVE		(0x1050UL)
#define CKM_ECDH1_COFACTOR_DERIVE	(0x1051UL)
#define CKM_ECMQV_DERIVE		(0x1052UL)
#define CKM_JUNIPER_KEY_GEN		(0x1060UL)
#define CKM_JUNIPER_ECB128		(0x1061UL)
#define CKM_JUNIPER_CBC128		(0x1062UL)
#define CKM_JUNIPER_COUNTER		(0x1063UL)
#define CKM_JUNIPER_SHUFFLE		(0x1064UL)
#define CKM_JUNIPER_WRAP		(0x1065UL)
#define CKM_FASTHASH			(0x1070UL)
#define CKM_AES_KEY_GEN			(0x1080UL)
#define CKM_AES_ECB			(0x1081UL)
#define CKM_AES_CBC			(0x1082UL)
#define CKM_AES_MAC			(0x1083UL)
#define CKM_AES_MAC_GENERAL		(0x1084UL)
#define CKM_AES_CBC_PAD			(0x1085UL)
/* AES counter mode is new for PKCS #11 v2.20 amendment 3 */
#define CKM_AES_CTR                     (0x1086UL)
/* BlowFish and TwoFish are new for v2.20 */
#define CKM_BLOWFISH_KEY_GEN            (0x1090UL)
#define CKM_BLOWFISH_CBC                (0x1091UL)
#define CKM_TWOFISH_KEY_GEN             (0x1092UL)
#define CKM_TWOFISH_CBC                 (0x1093UL)
/* CKM_xxx_ENCRYPT_DATA mechanisms are new for v2.20 */
#define CKM_DES_ECB_ENCRYPT_DATA        (0x1100UL)
#define CKM_DES_CBC_ENCRYPT_DATA        (0x1101UL)
#define CKM_DES3_ECB_ENCRYPT_DATA       (0x1102UL)
#define CKM_DES3_CBC_ENCRYPT_DATA       (0x1103UL)
#define CKM_AES_ECB_ENCRYPT_DATA        (0x1104UL)
#define CKM_AES_CBC_ENCRYPT_DATA        (0x1105UL)
#define CKM_DSA_PARAMETER_GEN		(0x2000UL)
#define CKM_DH_PKCS_PARAMETER_GEN	(0x2001UL)
#define CKM_X9_42_DH_PARAMETER_GEN	(0x2002UL)
#define CKM_VENDOR_DEFINED		((unsigned long) (1UL << 31))

struct ck_mechanism {
  ck_mechanism_type_t mechanism;
  [size_is(parameter_len)] char parameter[];
  [nativeint] unsigned long parameter_len;
};

struct ck_mechanism_info {
  [nativeint] unsigned long min_key_size;
  [nativeint] unsigned long max_key_size;
  ck_flags_t flags;
};

#define CKF_HW			(1UL << 0)
#define CKF_ENCRYPT		(1UL << 8)
#define CKF_DECRYPT		(1UL << 9)
#define CKF_DIGEST		(1UL << 10)
#define CKF_SIGN		(1UL << 11)
#define CKF_SIGN_RECOVER	(1UL << 12)
#define CKF_VERIFY		(1UL << 13)
#define CKF_VERIFY_RECOVER	(1UL << 14)
#define CKF_GENERATE		(1UL << 15)
#define CKF_GENERATE_KEY_PAIR	(1UL << 16)
#define CKF_WRAP		(1UL << 17)
#define CKF_UNWRAP		(1UL << 18)
#define CKF_DERIVE		(1UL << 19)
/* CKF_EC_F_P, CKF_EC_F_2M, CKF_EC_ECPARAMETERS, CKF_EC_NAMEDCURVE,
 * CKF_EC_UNCOMPRESS, and CKF_EC_COMPRESS are new for v2.11. They
 * describe a token's EC capabilities not available in mechanism
 * information. */
#define CKF_EC_F_P             (1UL << 20)
#define CKF_EC_F_2M            (1UL << 21)
#define CKF_EC_ECPARAMETERS    (1UL << 22)
#define CKF_EC_NAMEDCURVE      (1UL << 23)
#define CKF_EC_UNCOMPRESS      (1UL << 24)
#define CKF_EC_COMPRESS        (1UL << 25)
#define CKF_EXTENSION		((unsigned long) (1UL << 31))

/* Flags for C_WaitForSlotEvent.  */
#define CKF_DONT_BLOCK				(1UL)

#define CKF_LIBRARY_CANT_CREATE_OS_THREADS	(1UL << 0)
#define CKF_OS_LOCKING_OK			(1UL << 1)

#define CKR_OK					(0UL)
#define CKR_CANCEL				(1UL)
#define CKR_HOST_MEMORY				(2UL)
#define CKR_SLOT_ID_INVALID			(3UL)
#define CKR_GENERAL_ERROR			(5UL)
#define CKR_FUNCTION_FAILED			(6UL)
#define CKR_ARGUMENTS_BAD			(7UL)
#define CKR_NO_EVENT				(8UL)
#define CKR_NEED_TO_CREATE_THREADS		(9UL)
#define CKR_CANT_LOCK				(0xaUL)
#define CKR_ATTRIBUTE_READ_ONLY			(0x10UL)
#define CKR_ATTRIBUTE_SENSITIVE			(0x11UL)
#define CKR_ATTRIBUTE_TYPE_INVALID		(0x12UL)
#define CKR_ATTRIBUTE_VALUE_INVALID		(0x13UL)
#define CKR_DATA_INVALID			(0x20UL)
#define CKR_DATA_LEN_RANGE			(0x21UL)
#define CKR_DEVICE_ERROR			(0x30UL)
#define CKR_DEVICE_MEMORY			(0x31UL)
#define CKR_DEVICE_REMOVED			(0x32UL)
#define CKR_ENCRYPTED_DATA_INVALID		(0x40UL)
#define CKR_ENCRYPTED_DATA_LEN_RANGE		(0x41UL)
#define CKR_FUNCTION_CANCELED			(0x50UL)
#define CKR_FUNCTION_NOT_PARALLEL		(0x51UL)
#define CKR_FUNCTION_NOT_SUPPORTED		(0x54UL)
#define CKR_KEY_HANDLE_INVALID			(0x60UL)
#define CKR_KEY_SIZE_RANGE			(0x62UL)
#define CKR_KEY_TYPE_INCONSISTENT		(0x63UL)
#define CKR_KEY_NOT_NEEDED			(0x64UL)
#define CKR_KEY_CHANGED				(0x65UL)
#define CKR_KEY_NEEDED				(0x66UL)
#define CKR_KEY_INDIGESTIBLE			(0x67UL)
#define CKR_KEY_FUNCTION_NOT_PERMITTED		(0x68UL)
#define CKR_KEY_NOT_WRAPPABLE			(0x69UL)
#define CKR_KEY_UNEXTRACTABLE			(0x6aUL)
#define CKR_MECHANISM_INVALID			(0x70UL)
#define CKR_MECHANISM_PARAM_INVALID		(0x71UL)
#define CKR_OBJECT_HANDLE_INVALID		(0x82UL)
#define CKR_OPERATION_ACTIVE			(0x90UL)
#define CKR_OPERATION_NOT_INITIALIZED		(0x91UL)
#define CKR_PIN_INCORRECT			(0xa0UL)
#define CKR_PIN_INVALID				(0xa1UL)
#define CKR_PIN_LEN_RANGE			(0xa2UL)
#define CKR_PIN_EXPIRED				(0xa3UL)
#define CKR_PIN_LOCKED				(0xa4UL)
#define CKR_SESSION_CLOSED			(0xb0UL)
#define CKR_SESSION_COUNT			(0xb1UL)
#define CKR_SESSION_HANDLE_INVALID		(0xb3UL)
#define CKR_SESSION_PARALLEL_NOT_SUPPORTED	(0xb4UL)
#define CKR_SESSION_READ_ONLY			(0xb5UL)
#define CKR_SESSION_EXISTS			(0xb6UL)
#define CKR_SESSION_READ_ONLY_EXISTS		(0xb7UL)
#define CKR_SESSION_READ_WRITE_SO_EXISTS	(0xb8UL)
#define CKR_SIGNATURE_INVALID			(0xc0UL)
#define CKR_SIGNATURE_LEN_RANGE			(0xc1UL)
#define CKR_TEMPLATE_INCOMPLETE			(0xd0UL)
#define CKR_TEMPLATE_INCONSISTENT		(0xd1UL)
#define CKR_TOKEN_NOT_PRESENT			(0xe0UL)
#define CKR_TOKEN_NOT_RECOGNIZED		(0xe1UL)
#define CKR_TOKEN_WRITE_PROTECTED		(0xe2UL)
#define	CKR_UNWRAPPING_KEY_HANDLE_INVALID	(0xf0UL)
#define CKR_UNWRAPPING_KEY_SIZE_RANGE		(0xf1UL)
#define CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT	(0xf2UL)
#define CKR_USER_ALREADY_LOGGED_IN		(0x100UL)
#define CKR_USER_NOT_LOGGED_IN			(0x101UL)
#define CKR_USER_PIN_NOT_INITIALIZED		(0x102UL)
#define CKR_USER_TYPE_INVALID			(0x103UL)
#define CKR_USER_ANOTHER_ALREADY_LOGGED_IN	(0x104UL)
#define CKR_USER_TOO_MANY_TYPES			(0x105UL)
#define CKR_WRAPPED_KEY_INVALID			(0x110UL)
#define CKR_WRAPPED_KEY_LEN_RANGE		(0x112UL)
#define CKR_WRAPPING_KEY_HANDLE_INVALID		(0x113UL)
#define CKR_WRAPPING_KEY_SIZE_RANGE		(0x114UL)
#define CKR_WRAPPING_KEY_TYPE_INCONSISTENT	(0x115UL)
#define CKR_RANDOM_SEED_NOT_SUPPORTED		(0x120UL)
#define CKR_RANDOM_NO_RNG			(0x121UL)
#define CKR_DOMAIN_PARAMS_INVALID		(0x130UL)
#define CKR_BUFFER_TOO_SMALL			(0x150UL)
#define CKR_SAVED_STATE_INVALID			(0x160UL)
#define CKR_INFORMATION_SENSITIVE		(0x170UL)
#define CKR_STATE_UNSAVEABLE			(0x180UL)
#define CKR_CRYPTOKI_NOT_INITIALIZED		(0x190UL)
#define CKR_CRYPTOKI_ALREADY_INITIALIZED	(0x191UL)
#define CKR_MUTEX_BAD				(0x1a0UL)
#define CKR_MUTEX_NOT_LOCKED			(0x1a1UL)
/* The following return values are new for PKCS #11 v2.20 amendment 3 */
#define CKR_NEW_PIN_MODE                        (0x1b0UL)
#define CKR_NEXT_OTP                            (0x1b1UL)
#define CKR_FUNCTION_REJECTED			(0x200UL)
#define CKR_VENDOR_DEFINED			((unsigned long) (1UL << 31))

quote(mli, "val cRYPTOKI_VERSION_MAJOR  : nativeint");
quote(mli, "val cRYPTOKI_VERSION_MINOR  : nativeint");
quote(mli, "val cRYPTOKI_VERSION_REVISION : nativeint");
quote(mli, "val cKN_SURRENDER : nativeint");
quote(mli, "val cKN_OTP_CHANGED : nativeint");
quote(mli, "val cKF_TOKEN_PRESENT : nativeint");
quote(mli, "val cKF_REMOVABLE_DEVICE : nativeint");
quote(mli, "val cKF_HW_SLOT  : nativeint");
quote(mli, "val cKF_ARRAY_ATTRIBUTE : nativeint");
quote(mli, "val cKF_RNG     : nativeint");
quote(mli, "val cKF_WRITE_PROTECTED   : nativeint");
quote(mli, "val cKF_LOGIN_REQUIRED   : nativeint");
quote(mli, "val cKF_USER_PIN_INITIALIZED  : nativeint");
quote(mli, "val cKF_RESTORE_KEY_NOT_NEEDED  : nativeint");
quote(mli, "val cKF_CLOCK_ON_TOKEN   : nativeint");
quote(mli, "val cKF_PROTECTED_AUTHENTICATION_PATH : nativeint");
quote(mli, "val cKF_DUAL_CRYPTO_OPERATIONS  : nativeint");
quote(mli, "val cKF_TOKEN_INITIALIZED   : nativeint");
quote(mli, "val cKF_SECONDARY_AUTHENTICATION  : nativeint");
quote(mli, "val cKF_USER_PIN_COUNT_LOW   : nativeint");
quote(mli, "val cKF_USER_PIN_FINAL_TRY   : nativeint");
quote(mli, "val cKF_USER_PIN_LOCKED   : nativeint");
quote(mli, "val cKF_USER_PIN_TO_BE_CHANGED  : nativeint");
quote(mli, "val cKF_SO_PIN_COUNT_LOW   : nativeint");
quote(mli, "val cKF_SO_PIN_FINAL_TRY   : nativeint");
quote(mli, "val cKF_SO_PIN_LOCKED   : nativeint");
quote(mli, "val cKF_SO_PIN_TO_BE_CHANGED  : nativeint");
quote(mli, "val cK_UNAVAILABLE_INFORMATION : nativeint");
quote(mli, "val cK_EFFECTIVELY_INFINITE  : nativeint");
quote(mli, "val cK_INVALID_HANDLE : nativeint");
quote(mli, "val cKU_SO   : nativeint");
quote(mli, "val cKU_USER  : nativeint");
quote(mli, "val cKU_CONTEXT_SPECIFIC : nativeint");
quote(mli, "val cKS_RO_PUBLIC_SESSION : nativeint");
quote(mli, "val cKS_RO_USER_FUNCTIONS : nativeint");
quote(mli, "val cKS_RW_PUBLIC_SESSION : nativeint");
quote(mli, "val cKS_RW_USER_FUNCTIONS : nativeint");
quote(mli, "val cKS_RW_SO_FUNCTIONS : nativeint");
quote(mli, "val cKF_RW_SESSION  : nativeint");
quote(mli, "val cKF_SERIAL_SESSION : nativeint");
quote(mli, "val cKO_DATA  : nativeint");
quote(mli, "val cKO_CERTIFICATE  : nativeint");
quote(mli, "val cKO_PUBLIC_KEY  : nativeint");
quote(mli, "val cKO_PRIVATE_KEY  : nativeint");
quote(mli, "val cKO_SECRET_KEY  : nativeint");
quote(mli, "val cKO_HW_FEATURE  : nativeint");
quote(mli, "val cKO_DOMAIN_PARAMETERS : nativeint");
quote(mli, "val cKO_MECHANISM  : nativeint");
quote(mli, "val cKO_OTP_KEY : nativeint");
quote(mli, "val cKO_VENDOR_DEFINED : nativeint");
quote(mli, "val cKH_MONOTONIC_COUNTER : nativeint");
quote(mli, "val cKH_CLOCK  : nativeint");
quote(mli, "val cKH_USER_INTERFACE : nativeint");
quote(mli, "val cKH_VENDOR_DEFINED : nativeint");
quote(mli, "val cKK_RSA   : nativeint");
quote(mli, "val cKK_DSA   : nativeint");
quote(mli, "val cKK_DH   : nativeint");
quote(mli, "val cKK_ECDSA  : nativeint");
quote(mli, "val cKK_EC   : nativeint");
quote(mli, "val cKK_X9_42_DH  : nativeint");
quote(mli, "val cKK_KEA   : nativeint");
quote(mli, "val cKK_GENERIC_SECRET : nativeint");
quote(mli, "val cKK_RC2   : nativeint");
quote(mli, "val cKK_RC4   : nativeint");
quote(mli, "val cKK_DES   : nativeint");
quote(mli, "val cKK_DES2  : nativeint");
quote(mli, "val cKK_DES3  : nativeint");
quote(mli, "val cKK_CAST  : nativeint");
quote(mli, "val cKK_CAST3  : nativeint");
quote(mli, "val cKK_CAST128  : nativeint");
quote(mli, "val cKK_RC5   : nativeint");
quote(mli, "val cKK_IDEA  : nativeint");
quote(mli, "val cKK_SKIPJACK  : nativeint");
quote(mli, "val cKK_BATON  : nativeint");
quote(mli, "val cKK_JUNIPER  : nativeint");
quote(mli, "val cKK_CDMF  : nativeint");
quote(mli, "val cKK_AES   : nativeint");
quote(mli, "val cKK_BLOWFISH  : nativeint");
quote(mli, "val cKK_TWOFISH  : nativeint");
quote(mli, "val cKK_SECURID  : nativeint");
quote(mli, "val cKK_HOTP  : nativeint");
quote(mli, "val cKK_ACTI  : nativeint");
quote(mli, "val cKK_CAMELLIA  : nativeint");
quote(mli, "val cKK_ARIA  : nativeint");
quote(mli, "val cKK_VENDOR_DEFINED : nativeint");
quote(mli, "val cKC_X_509  : nativeint");
quote(mli, "val cKC_X_509_ATTR_CERT : nativeint");
quote(mli, "val cKC_WTLS  : nativeint");
quote(mli, "val cKC_VENDOR_DEFINED : nativeint");
quote(mli, "val cK_OTP_FORMAT_DECIMAL   : nativeint");
quote(mli, "val cK_OTP_FORMAT_HEXADECIMAL   : nativeint");
quote(mli, "val cK_OTP_FORMAT_ALPHANUMERIC   : nativeint");
quote(mli, "val cK_OTP_PARAM_IGNORED   : nativeint");
quote(mli, "val cK_OTP_PARAM_OPTIONAL   : nativeint");
quote(mli, "val cK_OTP_PARAM_MANDATORY   : nativeint");
quote(mli, "val cKA_CLASS   : nativeint");
quote(mli, "val cKA_TOKEN   : nativeint");
quote(mli, "val cKA_PRIVATE   : nativeint");
quote(mli, "val cKA_LABEL   : nativeint");
quote(mli, "val cKA_APPLICATION   : nativeint");
quote(mli, "val cKA_VALUE   : nativeint");
quote(mli, "val cKA_OBJECT_ID   : nativeint");
quote(mli, "val cKA_CERTIFICATE_TYPE  : nativeint");
quote(mli, "val cKA_ISSUER   : nativeint");
quote(mli, "val cKA_SERIAL_NUMBER  : nativeint");
quote(mli, "val cKA_AC_ISSUER   : nativeint");
quote(mli, "val cKA_OWNER   : nativeint");
quote(mli, "val cKA_ATTR_TYPES   : nativeint");
quote(mli, "val cKA_TRUSTED   : nativeint");
quote(mli, "val cKA_CERTIFICATE_CATEGORY : nativeint");
quote(mli, "val cKA_JAVA_MIDP_SECURITY_DOMAIN : nativeint");
quote(mli, "val cKA_URL    : nativeint");
quote(mli, "val cKA_HASH_OF_SUBJECT_PUBLIC_KEY : nativeint");
quote(mli, "val cKA_HASH_OF_ISSUER_PUBLIC_KEY : nativeint");
quote(mli, "val cKA_CHECK_VALUE   : nativeint");
quote(mli, "val cKA_KEY_TYPE   : nativeint");
quote(mli, "val cKA_SUBJECT   : nativeint");
quote(mli, "val cKA_ID    : nativeint");
quote(mli, "val cKA_SENSITIVE   : nativeint");
quote(mli, "val cKA_ENCRYPT   : nativeint");
quote(mli, "val cKA_DECRYPT   : nativeint");
quote(mli, "val cKA_WRAP   : nativeint");
quote(mli, "val cKA_UNWRAP   : nativeint");
quote(mli, "val cKA_SIGN   : nativeint");
quote(mli, "val cKA_SIGN_RECOVER  : nativeint");
quote(mli, "val cKA_VERIFY   : nativeint");
quote(mli, "val cKA_VERIFY_RECOVER  : nativeint");
quote(mli, "val cKA_DERIVE   : nativeint");
quote(mli, "val cKA_START_DATE   : nativeint");
quote(mli, "val cKA_END_DATE   : nativeint");
quote(mli, "val cKA_MODULUS   : nativeint");
quote(mli, "val cKA_MODULUS_BITS  : nativeint");
quote(mli, "val cKA_PUBLIC_EXPONENT  : nativeint");
quote(mli, "val cKA_PRIVATE_EXPONENT  : nativeint");
quote(mli, "val cKA_PRIME_1   : nativeint");
quote(mli, "val cKA_PRIME_2   : nativeint");
quote(mli, "val cKA_EXPONENT_1   : nativeint");
quote(mli, "val cKA_EXPONENT_2   : nativeint");
quote(mli, "val cKA_COEFFICIENT   : nativeint");
quote(mli, "val cKA_PRIME   : nativeint");
quote(mli, "val cKA_SUBPRIME   : nativeint");
quote(mli, "val cKA_BASE   : nativeint");
quote(mli, "val cKA_PRIME_BITS   : nativeint");
quote(mli, "val cKA_SUB_PRIME_BITS  : nativeint");
quote(mli, "val cKA_VALUE_BITS   : nativeint");
quote(mli, "val cKA_VALUE_LEN   : nativeint");
quote(mli, "val cKA_EXTRACTABLE   : nativeint");
quote(mli, "val cKA_LOCAL   : nativeint");
quote(mli, "val cKA_NEVER_EXTRACTABLE  : nativeint");
quote(mli, "val cKA_ALWAYS_SENSITIVE  : nativeint");
quote(mli, "val cKA_KEY_GEN_MECHANISM  : nativeint");
quote(mli, "val cKA_MODIFIABLE   : nativeint");
quote(mli, "val cKA_ECDSA_PARAMS  : nativeint");
quote(mli, "val cKA_EC_PARAMS   : nativeint");
quote(mli, "val cKA_EC_POINT   : nativeint");
quote(mli, "val cKA_SECONDARY_AUTH  : nativeint");
quote(mli, "val cKA_AUTH_PIN_FLAGS  : nativeint");
quote(mli, "val cKA_ALWAYS_AUTHENTICATE  : nativeint");
quote(mli, "val cKA_WRAP_WITH_TRUSTED  : nativeint");
quote(mli, "val cKA_OTP_FORMAT  : nativeint");
quote(mli, "val cKA_OTP_LENGTH  : nativeint");
quote(mli, "val cKA_OTP_TIME_INTERVAL  : nativeint");
quote(mli, "val cKA_OTP_USER_FRIENDLY_MODE  : nativeint");
quote(mli, "val cKA_OTP_CHALLENGE_REQUIREMENT  : nativeint");
quote(mli, "val cKA_OTP_TIME_REQUIREMENT  : nativeint");
quote(mli, "val cKA_OTP_COUNTER_REQUIREMENT  : nativeint");
quote(mli, "val cKA_OTP_PIN_REQUIREMENT  : nativeint");
quote(mli, "val cKA_OTP_COUNTER  : nativeint");
quote(mli, "val cKA_OTP_TIME  : nativeint");
quote(mli, "val cKA_OTP_USER_IDENTIFIER  : nativeint");
quote(mli, "val cKA_OTP_SERVICE_IDENTIFIER  : nativeint");
quote(mli, "val cKA_OTP_SERVICE_LOGO  : nativeint");
quote(mli, "val cKA_OTP_SERVICE_LOGO_TYPE  : nativeint");
quote(mli, "val cKA_HW_FEATURE_TYPE  : nativeint");
quote(mli, "val cKA_RESET_ON_INIT  : nativeint");
quote(mli, "val cKA_HAS_RESET   : nativeint");
quote(mli, "val cKA_PIXEL_X   : nativeint");
quote(mli, "val cKA_PIXEL_Y   : nativeint");
quote(mli, "val cKA_RESOLUTION   : nativeint");
quote(mli, "val cKA_CHAR_ROWS   : nativeint");
quote(mli, "val cKA_CHAR_COLUMNS  : nativeint");
quote(mli, "val cKA_COLOR   : nativeint");
quote(mli, "val cKA_BITS_PER_PIXEL  : nativeint");
quote(mli, "val cKA_CHAR_SETS   : nativeint");
quote(mli, "val cKA_ENCODING_METHODS  : nativeint");
quote(mli, "val cKA_MIME_TYPES   : nativeint");
quote(mli, "val cKA_MECHANISM_TYPE  : nativeint");
quote(mli, "val cKA_REQUIRED_CMS_ATTRIBUTES : nativeint");
quote(mli, "val cKA_DEFAULT_CMS_ATTRIBUTES : nativeint");
quote(mli, "val cKA_SUPPORTED_CMS_ATTRIBUTES : nativeint");
quote(mli, "val cKA_WRAP_TEMPLATE  : nativeint");
quote(mli, "val cKA_UNWRAP_TEMPLATE  : nativeint");
quote(mli, "val cKA_ALLOWED_MECHANISMS  : nativeint");
quote(mli, "val cKA_VENDOR_DEFINED  : nativeint");
quote(mli, "val cKM_RSA_PKCS_KEY_PAIR_GEN : nativeint");
quote(mli, "val cKM_RSA_PKCS   : nativeint");
quote(mli, "val cKM_RSA_9796   : nativeint");
quote(mli, "val cKM_RSA_X_509   : nativeint");
quote(mli, "val cKM_MD2_RSA_PKCS  : nativeint");
quote(mli, "val cKM_MD5_RSA_PKCS  : nativeint");
quote(mli, "val cKM_SHA1_RSA_PKCS  : nativeint");
quote(mli, "val cKM_RIPEMD128_RSA_PKCS  : nativeint");
quote(mli, "val cKM_RIPEMD160_RSA_PKCS  : nativeint");
quote(mli, "val cKM_RSA_PKCS_OAEP  : nativeint");
quote(mli, "val cKM_RSA_X9_31_KEY_PAIR_GEN : nativeint");
quote(mli, "val cKM_RSA_X9_31   : nativeint");
quote(mli, "val cKM_SHA1_RSA_X9_31  : nativeint");
quote(mli, "val cKM_RSA_PKCS_PSS  : nativeint");
quote(mli, "val cKM_SHA1_RSA_PKCS_PSS  : nativeint");
quote(mli, "val cKM_DSA_KEY_PAIR_GEN  : nativeint");
quote(mli, "val cKM_DSA    : nativeint");
quote(mli, "val cKM_DSA_SHA1   : nativeint");
quote(mli, "val cKM_DH_PKCS_KEY_PAIR_GEN : nativeint");
quote(mli, "val cKM_DH_PKCS_DERIVE  : nativeint");
quote(mli, "val cKM_X9_42_DH_KEY_PAIR_GEN : nativeint");
quote(mli, "val cKM_X9_42_DH_DERIVE  : nativeint");
quote(mli, "val cKM_X9_42_DH_HYBRID_DERIVE : nativeint");
quote(mli, "val cKM_X9_42_MQV_DERIVE  : nativeint");
quote(mli, "val cKM_SHA256_RSA_PKCS  : nativeint");
quote(mli, "val cKM_SHA384_RSA_PKCS  : nativeint");
quote(mli, "val cKM_SHA512_RSA_PKCS  : nativeint");
quote(mli, "val cKM_SHA224_RSA_PKCS  : nativeint");
quote(mli, "val cKM_SHA256_RSA_PKCS_PSS  : nativeint");
quote(mli, "val cKM_SHA384_RSA_PKCS_PSS  : nativeint");
quote(mli, "val cKM_SHA512_RSA_PKCS_PSS  : nativeint");
quote(mli, "val cKM_SHA224_RSA_PKCS_PSS  : nativeint");
quote(mli, "val cKM_RC2_KEY_GEN   : nativeint");
quote(mli, "val cKM_RC2_ECB   : nativeint");
quote(mli, "val cKM_RC2_CBC   : nativeint");
quote(mli, "val cKM_RC2_MAC   : nativeint");
quote(mli, "val cKM_RC2_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_RC2_CBC_PAD   : nativeint");
quote(mli, "val cKM_RC4_KEY_GEN   : nativeint");
quote(mli, "val cKM_RC4    : nativeint");
quote(mli, "val cKM_DES_KEY_GEN   : nativeint");
quote(mli, "val cKM_DES_ECB   : nativeint");
quote(mli, "val cKM_DES_CBC   : nativeint");
quote(mli, "val cKM_DES_MAC   : nativeint");
quote(mli, "val cKM_DES_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_DES_CBC_PAD   : nativeint");
quote(mli, "val cKM_DES2_KEY_GEN  : nativeint");
quote(mli, "val cKM_DES3_KEY_GEN  : nativeint");
quote(mli, "val cKM_DES3_ECB   : nativeint");
quote(mli, "val cKM_DES3_CBC   : nativeint");
quote(mli, "val cKM_DES3_MAC   : nativeint");
quote(mli, "val cKM_DES3_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_DES3_CBC_PAD  : nativeint");
quote(mli, "val cKM_CDMF_KEY_GEN  : nativeint");
quote(mli, "val cKM_CDMF_ECB   : nativeint");
quote(mli, "val cKM_CDMF_CBC   : nativeint");
quote(mli, "val cKM_CDMF_MAC   : nativeint");
quote(mli, "val cKM_CDMF_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_CDMF_CBC_PAD  : nativeint");
quote(mli, "val cKM_MD2    : nativeint");
quote(mli, "val cKM_MD2_HMAC   : nativeint");
quote(mli, "val cKM_MD2_HMAC_GENERAL  : nativeint");
quote(mli, "val cKM_MD5    : nativeint");
quote(mli, "val cKM_MD5_HMAC   : nativeint");
quote(mli, "val cKM_MD5_HMAC_GENERAL  : nativeint");
quote(mli, "val cKM_SHA_1   : nativeint");
quote(mli, "val cKM_SHA_1_HMAC   : nativeint");
quote(mli, "val cKM_SHA_1_HMAC_GENERAL  : nativeint");
quote(mli, "val cKM_RIPEMD128   : nativeint");
quote(mli, "val cKM_RIPEMD128_HMAC  : nativeint");
quote(mli, "val cKM_RIPEMD128_HMAC_GENERAL : nativeint");
quote(mli, "val cKM_RIPEMD160   : nativeint");
quote(mli, "val cKM_RIPEMD160_HMAC  : nativeint");
quote(mli, "val cKM_RIPEMD160_HMAC_GENERAL : nativeint");
quote(mli, "val cKM_SHA256   : nativeint");
quote(mli, "val cKM_SHA256_HMAC   : nativeint");
quote(mli, "val cKM_SHA256_HMAC_GENERAL  : nativeint");
quote(mli, "val cKM_SHA384   : nativeint");
quote(mli, "val cKM_SHA384_HMAC   : nativeint");
quote(mli, "val cKM_SHA384_HMAC_GENERAL  : nativeint");
quote(mli, "val cKM_SHA512   : nativeint");
quote(mli, "val cKM_SHA512_HMAC   : nativeint");
quote(mli, "val cKM_SHA512_HMAC_GENERAL  : nativeint");
quote(mli, "val cKM_SHA224   : nativeint");
quote(mli, "val cKM_SHA224_HMAC   : nativeint");
quote(mli, "val cKM_SHA224_HMAC_GENERAL  : nativeint");
quote(mli, "val cKM_SECURID_KEY_GEN  : nativeint");
quote(mli, "val cKM_SECURID  : nativeint");
quote(mli, "val cKM_HOTP_KEY_GEN  : nativeint");
quote(mli, "val cKM_HOTP  : nativeint");
quote(mli, "val cKM_ACTI_KEY_GEN  : nativeint");
quote(mli, "val cKM_ACTI  : nativeint");
quote(mli, "val cKM_CAST_KEY_GEN  : nativeint");
quote(mli, "val cKM_CAST_ECB   : nativeint");
quote(mli, "val cKM_CAST_CBC   : nativeint");
quote(mli, "val cKM_CAST_MAC   : nativeint");
quote(mli, "val cKM_CAST_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_CAST_CBC_PAD  : nativeint");
quote(mli, "val cKM_CAST3_KEY_GEN  : nativeint");
quote(mli, "val cKM_CAST3_ECB   : nativeint");
quote(mli, "val cKM_CAST3_CBC   : nativeint");
quote(mli, "val cKM_CAST3_MAC   : nativeint");
quote(mli, "val cKM_CAST3_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_CAST3_CBC_PAD  : nativeint");
quote(mli, "val cKM_CAST5_KEY_GEN  : nativeint");
quote(mli, "val cKM_CAST128_KEY_GEN  : nativeint");
quote(mli, "val cKM_CAST5_ECB   : nativeint");
quote(mli, "val cKM_CAST128_ECB   : nativeint");
quote(mli, "val cKM_CAST5_CBC   : nativeint");
quote(mli, "val cKM_CAST128_CBC   : nativeint");
quote(mli, "val cKM_CAST5_MAC   : nativeint");
quote(mli, "val cKM_CAST128_MAC   : nativeint");
quote(mli, "val cKM_CAST5_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_CAST128_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_CAST5_CBC_PAD  : nativeint");
quote(mli, "val cKM_CAST128_CBC_PAD  : nativeint");
quote(mli, "val cKM_RC5_KEY_GEN   : nativeint");
quote(mli, "val cKM_RC5_ECB   : nativeint");
quote(mli, "val cKM_RC5_CBC   : nativeint");
quote(mli, "val cKM_RC5_MAC   : nativeint");
quote(mli, "val cKM_RC5_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_RC5_CBC_PAD   : nativeint");
quote(mli, "val cKM_IDEA_KEY_GEN  : nativeint");
quote(mli, "val cKM_IDEA_ECB   : nativeint");
quote(mli, "val cKM_IDEA_CBC   : nativeint");
quote(mli, "val cKM_IDEA_MAC   : nativeint");
quote(mli, "val cKM_IDEA_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_IDEA_CBC_PAD  : nativeint");
quote(mli, "val cKM_GENERIC_SECRET_KEY_GEN : nativeint");
quote(mli, "val cKM_CONCATENATE_BASE_AND_KEY : nativeint");
quote(mli, "val cKM_CONCATENATE_BASE_AND_DATA : nativeint");
quote(mli, "val cKM_CONCATENATE_DATA_AND_BASE : nativeint");
quote(mli, "val cKM_XOR_BASE_AND_DATA  : nativeint");
quote(mli, "val cKM_EXTRACT_KEY_FROM_KEY : nativeint");
quote(mli, "val cKM_SSL3_PRE_MASTER_KEY_GEN : nativeint");
quote(mli, "val cKM_SSL3_MASTER_KEY_DERIVE : nativeint");
quote(mli, "val cKM_SSL3_KEY_AND_MAC_DERIVE : nativeint");
quote(mli, "val cKM_SSL3_MASTER_KEY_DERIVE_DH : nativeint");
quote(mli, "val cKM_TLS_PRE_MASTER_KEY_GEN : nativeint");
quote(mli, "val cKM_TLS_MASTER_KEY_DERIVE : nativeint");
quote(mli, "val cKM_TLS_KEY_AND_MAC_DERIVE : nativeint");
quote(mli, "val cKM_TLS_MASTER_KEY_DERIVE_DH : nativeint");
quote(mli, "val cKM_TLS_PRF  : nativeint");
quote(mli, "val cKM_SSL3_MD5_MAC  : nativeint");
quote(mli, "val cKM_SSL3_SHA1_MAC  : nativeint");
quote(mli, "val cKM_MD5_KEY_DERIVATION  : nativeint");
quote(mli, "val cKM_MD2_KEY_DERIVATION  : nativeint");
quote(mli, "val cKM_SHA1_KEY_DERIVATION  : nativeint");
quote(mli, "val cKM_SHA256_KEY_DERIVATION  : nativeint");
quote(mli, "val cKM_SHA384_KEY_DERIVATION  : nativeint");
quote(mli, "val cKM_SHA512_KEY_DERIVATION  : nativeint");
quote(mli, "val cKM_SHA224_KEY_DERIVATION  : nativeint");
quote(mli, "val cKM_PBE_MD2_DES_CBC  : nativeint");
quote(mli, "val cKM_PBE_MD5_DES_CBC  : nativeint");
quote(mli, "val cKM_PBE_MD5_CAST_CBC  : nativeint");
quote(mli, "val cKM_PBE_MD5_CAST3_CBC  : nativeint");
quote(mli, "val cKM_PBE_MD5_CAST5_CBC  : nativeint");
quote(mli, "val cKM_PBE_MD5_CAST128_CBC  : nativeint");
quote(mli, "val cKM_PBE_SHA1_CAST5_CBC  : nativeint");
quote(mli, "val cKM_PBE_SHA1_CAST128_CBC : nativeint");
quote(mli, "val cKM_PBE_SHA1_RC4_128  : nativeint");
quote(mli, "val cKM_PBE_SHA1_RC4_40  : nativeint");
quote(mli, "val cKM_PBE_SHA1_DES3_EDE_CBC : nativeint");
quote(mli, "val cKM_PBE_SHA1_DES2_EDE_CBC : nativeint");
quote(mli, "val cKM_PBE_SHA1_RC2_128_CBC : nativeint");
quote(mli, "val cKM_PBE_SHA1_RC2_40_CBC  : nativeint");
quote(mli, "val cKM_PKCS5_PBKD2   : nativeint");
quote(mli, "val cKM_PBA_SHA1_WITH_SHA1_HMAC : nativeint");
quote(mli, "val cKM_WTLS_PRE_MASTER_KEY_GEN : nativeint");
quote(mli, "val cKM_WTLS_MASTER_KEY_DERIVE : nativeint");
quote(mli, "val cKM_WTLS_MASTER_KEY_DERIVE_DH_ECC : nativeint");
quote(mli, "val cKM_WTLS_PRF : nativeint");
quote(mli, "val cKM_WTLS_SERVER_KEY_AND_MAC_DERIVE : nativeint");
quote(mli, "val cKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE : nativeint");
quote(mli, "val cKM_KEY_WRAP_LYNKS  : nativeint");
quote(mli, "val cKM_KEY_WRAP_SET_OAEP  : nativeint");
quote(mli, "val cKM_CMS_SIG : nativeint");
quote(mli, "val cKM_KIP_DERIVE : nativeint");
quote(mli, "val cKM_KIP_WRAP : nativeint");
quote(mli, "val cKM_KIP_MAC : nativeint");
quote(mli, "val cKM_CAMELLIA_KEY_GEN : nativeint");
quote(mli, "val cKM_CAMELLIA_ECB : nativeint");
quote(mli, "val cKM_CAMELLIA_CBC : nativeint");
quote(mli, "val cKM_CAMELLIA_MAC : nativeint");
quote(mli, "val cKM_CAMELLIA_MAC_GENERAL : nativeint");
quote(mli, "val cKM_CAMELLIA_CBC_PAD : nativeint");
quote(mli, "val cKM_CAMELLIA_ECB_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_CAMELLIA_CBC_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_CAMELLIA_CTR : nativeint");
quote(mli, "val cKM_ARIA_KEY_GEN : nativeint");
quote(mli, "val cKM_ARIA_ECB : nativeint");
quote(mli, "val cKM_ARIA_CBC : nativeint");
quote(mli, "val cKM_ARIA_MAC : nativeint");
quote(mli, "val cKM_ARIA_MAC_GENERAL : nativeint");
quote(mli, "val cKM_ARIA_CBC_PAD : nativeint");
quote(mli, "val cKM_ARIA_ECB_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_ARIA_CBC_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_SKIPJACK_KEY_GEN  : nativeint");
quote(mli, "val cKM_SKIPJACK_ECB64  : nativeint");
quote(mli, "val cKM_SKIPJACK_CBC64  : nativeint");
quote(mli, "val cKM_SKIPJACK_OFB64  : nativeint");
quote(mli, "val cKM_SKIPJACK_CFB64  : nativeint");
quote(mli, "val cKM_SKIPJACK_CFB32  : nativeint");
quote(mli, "val cKM_SKIPJACK_CFB16  : nativeint");
quote(mli, "val cKM_SKIPJACK_CFB8  : nativeint");
quote(mli, "val cKM_SKIPJACK_WRAP  : nativeint");
quote(mli, "val cKM_SKIPJACK_PRIVATE_WRAP : nativeint");
quote(mli, "val cKM_SKIPJACK_RELAYX  : nativeint");
quote(mli, "val cKM_KEA_KEY_PAIR_GEN  : nativeint");
quote(mli, "val cKM_KEA_KEY_DERIVE  : nativeint");
quote(mli, "val cKM_FORTEZZA_TIMESTAMP  : nativeint");
quote(mli, "val cKM_BATON_KEY_GEN  : nativeint");
quote(mli, "val cKM_BATON_ECB128  : nativeint");
quote(mli, "val cKM_BATON_ECB96   : nativeint");
quote(mli, "val cKM_BATON_CBC128  : nativeint");
quote(mli, "val cKM_BATON_COUNTER  : nativeint");
quote(mli, "val cKM_BATON_SHUFFLE  : nativeint");
quote(mli, "val cKM_BATON_WRAP   : nativeint");
quote(mli, "val cKM_ECDSA_KEY_PAIR_GEN  : nativeint");
quote(mli, "val cKM_EC_KEY_PAIR_GEN  : nativeint");
quote(mli, "val cKM_ECDSA   : nativeint");
quote(mli, "val cKM_ECDSA_SHA1   : nativeint");
quote(mli, "val cKM_ECDH1_DERIVE  : nativeint");
quote(mli, "val cKM_ECDH1_COFACTOR_DERIVE : nativeint");
quote(mli, "val cKM_ECMQV_DERIVE  : nativeint");
quote(mli, "val cKM_JUNIPER_KEY_GEN  : nativeint");
quote(mli, "val cKM_JUNIPER_ECB128  : nativeint");
quote(mli, "val cKM_JUNIPER_CBC128  : nativeint");
quote(mli, "val cKM_JUNIPER_COUNTER  : nativeint");
quote(mli, "val cKM_JUNIPER_SHUFFLE  : nativeint");
quote(mli, "val cKM_JUNIPER_WRAP  : nativeint");
quote(mli, "val cKM_FASTHASH   : nativeint");
quote(mli, "val cKM_AES_KEY_GEN   : nativeint");
quote(mli, "val cKM_AES_ECB   : nativeint");
quote(mli, "val cKM_AES_CBC   : nativeint");
quote(mli, "val cKM_AES_MAC   : nativeint");
quote(mli, "val cKM_AES_MAC_GENERAL  : nativeint");
quote(mli, "val cKM_AES_CBC_PAD   : nativeint");
quote(mli, "val cKM_AES_CTR   : nativeint");
quote(mli, "val cKM_BLOWFISH_KEY_GEN : nativeint");
quote(mli, "val cKM_BLOWFISH_CBC : nativeint");
quote(mli, "val cKM_TWOFISH_KEY_GEN : nativeint");
quote(mli, "val cKM_TWOFISH_CBC : nativeint");
quote(mli, "val cKM_DES_ECB_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_DES_CBC_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_DES3_ECB_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_DES3_CBC_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_AES_ECB_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_AES_CBC_ENCRYPT_DATA : nativeint");
quote(mli, "val cKM_DSA_PARAMETER_GEN  : nativeint");
quote(mli, "val cKM_DH_PKCS_PARAMETER_GEN : nativeint");
quote(mli, "val cKM_X9_42_DH_PARAMETER_GEN : nativeint");
quote(mli, "val cKM_VENDOR_DEFINED  : nativeint");
quote(mli, "val cKF_HW   : nativeint");
quote(mli, "val cKF_ENCRYPT  : nativeint");
quote(mli, "val cKF_DECRYPT  : nativeint");
quote(mli, "val cKF_DIGEST  : nativeint");
quote(mli, "val cKF_SIGN  : nativeint");
quote(mli, "val cKF_SIGN_RECOVER : nativeint");
quote(mli, "val cKF_VERIFY  : nativeint");
quote(mli, "val cKF_VERIFY_RECOVER : nativeint");
quote(mli, "val cKF_GENERATE  : nativeint");
quote(mli, "val cKF_GENERATE_KEY_PAIR : nativeint");
quote(mli, "val cKF_WRAP  : nativeint");
quote(mli, "val cKF_UNWRAP  : nativeint");
quote(mli, "val cKF_DERIVE  : nativeint");
quote(mli, "val cKF_EC_F_P  : nativeint");
quote(mli, "val cKF_EC_F_2M  : nativeint");
quote(mli, "val cKF_EC_ECPARAMETERS  : nativeint");
quote(mli, "val cKF_EC_NAMEDCURVE  : nativeint");
quote(mli, "val cKF_EC_UNCOMPRESS  : nativeint");
quote(mli, "val cKF_EC_COMPRESS  : nativeint");
quote(mli, "val cKF_EXTENSION  : nativeint");
quote(mli, "val cKF_DONT_BLOCK    : nativeint");
quote(mli, "val cKF_LIBRARY_CANT_CREATE_OS_THREADS : nativeint");
quote(mli, "val cKF_OS_LOCKING_OK   : nativeint");
quote(mli, "val cKR_OK     : nativeint");
quote(mli, "val cKR_CANCEL    : nativeint");
quote(mli, "val cKR_HOST_MEMORY    : nativeint");
quote(mli, "val cKR_SLOT_ID_INVALID   : nativeint");
quote(mli, "val cKR_GENERAL_ERROR   : nativeint");
quote(mli, "val cKR_FUNCTION_FAILED   : nativeint");
quote(mli, "val cKR_ARGUMENTS_BAD   : nativeint");
quote(mli, "val cKR_NO_EVENT    : nativeint");
quote(mli, "val cKR_NEED_TO_CREATE_THREADS  : nativeint");
quote(mli, "val cKR_CANT_LOCK    : nativeint");
quote(mli, "val cKR_ATTRIBUTE_READ_ONLY   : nativeint");
quote(mli, "val cKR_ATTRIBUTE_SENSITIVE   : nativeint");
quote(mli, "val cKR_ATTRIBUTE_TYPE_INVALID  : nativeint");
quote(mli, "val cKR_ATTRIBUTE_VALUE_INVALID  : nativeint");
quote(mli, "val cKR_DATA_INVALID   : nativeint");
quote(mli, "val cKR_DATA_LEN_RANGE   : nativeint");
quote(mli, "val cKR_DEVICE_ERROR   : nativeint");
quote(mli, "val cKR_DEVICE_MEMORY   : nativeint");
quote(mli, "val cKR_DEVICE_REMOVED   : nativeint");
quote(mli, "val cKR_ENCRYPTED_DATA_INVALID  : nativeint");
quote(mli, "val cKR_ENCRYPTED_DATA_LEN_RANGE  : nativeint");
quote(mli, "val cKR_FUNCTION_CANCELED   : nativeint");
quote(mli, "val cKR_FUNCTION_NOT_PARALLEL  : nativeint");
quote(mli, "val cKR_FUNCTION_NOT_SUPPORTED  : nativeint");
quote(mli, "val cKR_KEY_HANDLE_INVALID   : nativeint");
quote(mli, "val cKR_KEY_SIZE_RANGE   : nativeint");
quote(mli, "val cKR_KEY_TYPE_INCONSISTENT  : nativeint");
quote(mli, "val cKR_KEY_NOT_NEEDED   : nativeint");
quote(mli, "val cKR_KEY_CHANGED    : nativeint");
quote(mli, "val cKR_KEY_NEEDED    : nativeint");
quote(mli, "val cKR_KEY_INDIGESTIBLE   : nativeint");
quote(mli, "val cKR_KEY_FUNCTION_NOT_PERMITTED  : nativeint");
quote(mli, "val cKR_KEY_NOT_WRAPPABLE   : nativeint");
quote(mli, "val cKR_KEY_UNEXTRACTABLE   : nativeint");
quote(mli, "val cKR_MECHANISM_INVALID   : nativeint");
quote(mli, "val cKR_MECHANISM_PARAM_INVALID  : nativeint");
quote(mli, "val cKR_OBJECT_HANDLE_INVALID  : nativeint");
quote(mli, "val cKR_OPERATION_ACTIVE   : nativeint");
quote(mli, "val cKR_OPERATION_NOT_INITIALIZED  : nativeint");
quote(mli, "val cKR_PIN_INCORRECT   : nativeint");
quote(mli, "val cKR_PIN_INVALID    : nativeint");
quote(mli, "val cKR_PIN_LEN_RANGE   : nativeint");
quote(mli, "val cKR_PIN_EXPIRED    : nativeint");
quote(mli, "val cKR_PIN_LOCKED    : nativeint");
quote(mli, "val cKR_SESSION_CLOSED   : nativeint");
quote(mli, "val cKR_SESSION_COUNT   : nativeint");
quote(mli, "val cKR_SESSION_HANDLE_INVALID  : nativeint");
quote(mli, "val cKR_SESSION_PARALLEL_NOT_SUPPORTED : nativeint");
quote(mli, "val cKR_SESSION_READ_ONLY   : nativeint");
quote(mli, "val cKR_SESSION_EXISTS   : nativeint");
quote(mli, "val cKR_SESSION_READ_ONLY_EXISTS  : nativeint");
quote(mli, "val cKR_SESSION_READ_WRITE_SO_EXISTS : nativeint");
quote(mli, "val cKR_SIGNATURE_INVALID   : nativeint");
quote(mli, "val cKR_SIGNATURE_LEN_RANGE   : nativeint");
quote(mli, "val cKR_TEMPLATE_INCOMPLETE   : nativeint");
quote(mli, "val cKR_TEMPLATE_INCONSISTENT  : nativeint");
quote(mli, "val cKR_TOKEN_NOT_PRESENT   : nativeint");
quote(mli, "val cKR_TOKEN_NOT_RECOGNIZED  : nativeint");
quote(mli, "val cKR_TOKEN_WRITE_PROTECTED  : nativeint");
quote(mli, "val cKR_UNWRAPPING_KEY_HANDLE_INVALID : nativeint");
quote(mli, "val cKR_UNWRAPPING_KEY_SIZE_RANGE  : nativeint");
quote(mli, "val cKR_UNWRAPPING_KEY_TYPE_INCONSISTENT : nativeint");
quote(mli, "val cKR_USER_ALREADY_LOGGED_IN  : nativeint");
quote(mli, "val cKR_USER_NOT_LOGGED_IN   : nativeint");
quote(mli, "val cKR_USER_PIN_NOT_INITIALIZED  : nativeint");
quote(mli, "val cKR_USER_TYPE_INVALID   : nativeint");
quote(mli, "val cKR_USER_ANOTHER_ALREADY_LOGGED_IN : nativeint");
quote(mli, "val cKR_USER_TOO_MANY_TYPES   : nativeint");
quote(mli, "val cKR_WRAPPED_KEY_INVALID   : nativeint");
quote(mli, "val cKR_WRAPPED_KEY_LEN_RANGE  : nativeint");
quote(mli, "val cKR_WRAPPING_KEY_HANDLE_INVALID  : nativeint");
quote(mli, "val cKR_WRAPPING_KEY_SIZE_RANGE  : nativeint");
quote(mli, "val cKR_WRAPPING_KEY_TYPE_INCONSISTENT : nativeint");
quote(mli, "val cKR_RANDOM_SEED_NOT_SUPPORTED  : nativeint");
quote(mli, "val cKR_RANDOM_NO_RNG   : nativeint");
quote(mli, "val cKR_DOMAIN_PARAMS_INVALID  : nativeint");
quote(mli, "val cKR_BUFFER_TOO_SMALL   : nativeint");
quote(mli, "val cKR_SAVED_STATE_INVALID   : nativeint");
quote(mli, "val cKR_INFORMATION_SENSITIVE  : nativeint");
quote(mli, "val cKR_STATE_UNSAVEABLE   : nativeint");
quote(mli, "val cKR_CRYPTOKI_NOT_INITIALIZED  : nativeint");
quote(mli, "val cKR_CRYPTOKI_ALREADY_INITIALIZED : nativeint");
quote(mli, "val cKR_MUTEX_BAD    : nativeint");
quote(mli, "val cKR_MUTEX_NOT_LOCKED   : nativeint");
quote(mli, "val cKR_NEW_PIN_MODE   : nativeint");
quote(mli, "val cKR_NEXT_OTP   : nativeint");
quote(mli, "val cKR_FUNCTION_REJECTED   : nativeint");
quote(mli, "val cKR_VENDOR_DEFINED   : nativeint");
quote(mli, "val cK_FALSE : nativeint");
quote(mli, "val cK_TRUE : nativeint");
quote(mli, "val fALSE : nativeint");
quote(mli, "val tRUE : nativeint");
quote(mli, "val nULL_PTR : nativeint");

quote(ml, "let cRYPTOKI_VERSION_MAJOR  = 2n");
quote(ml, "let cRYPTOKI_VERSION_MINOR  = 20n");
quote(ml, "let cRYPTOKI_VERSION_REVISION = 6n");
quote(ml, "let cKN_SURRENDER = 0n");
quote(ml, "let cKN_OTP_CHANGED = 1n");
quote(ml, "let cKF_TOKEN_PRESENT = 1n");
quote(ml, "let cKF_REMOVABLE_DEVICE = 2n");
quote(ml, "let cKF_HW_SLOT  = 4n");
quote(ml, "let cKF_ARRAY_ATTRIBUTE = 1073741824n");
quote(ml, "let cKF_RNG     = 1n");
quote(ml, "let cKF_WRITE_PROTECTED   = 2n");
quote(ml, "let cKF_LOGIN_REQUIRED   = 4n");
quote(ml, "let cKF_USER_PIN_INITIALIZED  = 8n");
quote(ml, "let cKF_RESTORE_KEY_NOT_NEEDED  = 32n");
quote(ml, "let cKF_CLOCK_ON_TOKEN   = 64n");
quote(ml, "let cKF_PROTECTED_AUTHENTICATION_PATH = 256n");
quote(ml, "let cKF_DUAL_CRYPTO_OPERATIONS  = 512n");
quote(ml, "let cKF_TOKEN_INITIALIZED   = 1024n");
quote(ml, "let cKF_SECONDARY_AUTHENTICATION  = 2048n");
quote(ml, "let cKF_USER_PIN_COUNT_LOW   = 65536n");
quote(ml, "let cKF_USER_PIN_FINAL_TRY   = 131072n");
quote(ml, "let cKF_USER_PIN_LOCKED   = 262144n");
quote(ml, "let cKF_USER_PIN_TO_BE_CHANGED  = 524288n");
quote(ml, "let cKF_SO_PIN_COUNT_LOW   = 1048576n");
quote(ml, "let cKF_SO_PIN_FINAL_TRY   = 2097152n");
quote(ml, "let cKF_SO_PIN_LOCKED   = 4194304n");
quote(ml, "let cKF_SO_PIN_TO_BE_CHANGED  = 8388608n");
quote(ml, "let cK_UNAVAILABLE_INFORMATION = (Nativeint.minus_one)");
quote(ml, "let cK_EFFECTIVELY_INFINITE  = 0n");
quote(ml, "let cK_INVALID_HANDLE = 0n");
quote(ml, "let cKU_SO   = 0n");
quote(ml, "let cKU_USER  = 1n");
quote(ml, "let cKU_CONTEXT_SPECIFIC = 2n");
quote(ml, "let cKS_RO_PUBLIC_SESSION = 0n");
quote(ml, "let cKS_RO_USER_FUNCTIONS = 1n");
quote(ml, "let cKS_RW_PUBLIC_SESSION = 2n");
quote(ml, "let cKS_RW_USER_FUNCTIONS = 3n");
quote(ml, "let cKS_RW_SO_FUNCTIONS = 4n");
quote(ml, "let cKF_RW_SESSION  = 2n");
quote(ml, "let cKF_SERIAL_SESSION = 4n");
quote(ml, "let cKO_DATA  = 0n");
quote(ml, "let cKO_CERTIFICATE  = 1n");
quote(ml, "let cKO_PUBLIC_KEY  = 2n");
quote(ml, "let cKO_PRIVATE_KEY  = 3n");
quote(ml, "let cKO_SECRET_KEY  = 4n");
quote(ml, "let cKO_HW_FEATURE  = 5n");
quote(ml, "let cKO_DOMAIN_PARAMETERS = 6n");
quote(ml, "let cKO_MECHANISM  = 7n");
quote(ml, "let cKO_OTP_KEY  = 8n");
#if __LP64__
quote(ml, "let cKO_VENDOR_DEFINED = 2147483648n");
#else
quote(ml, "let cKO_VENDOR_DEFINED = -2147483648n");
#endif
quote(ml, "let cKH_MONOTONIC_COUNTER = 1n");
quote(ml, "let cKH_CLOCK  = 2n");
quote(ml, "let cKH_USER_INTERFACE = 3n");
#if __LP64__
quote(ml, "let cKH_VENDOR_DEFINED = 2147483648n");
#else
quote(ml, "let cKH_VENDOR_DEFINED = -2147483648n");
#endif
quote(ml, "let cKK_RSA   = 0n");
quote(ml, "let cKK_DSA   = 1n");
quote(ml, "let cKK_DH   = 2n");
quote(ml, "let cKK_ECDSA  = 3n");
quote(ml, "let cKK_EC   = 3n");
quote(ml, "let cKK_X9_42_DH  = 4n");
quote(ml, "let cKK_KEA   = 5n");
quote(ml, "let cKK_GENERIC_SECRET = 16n");
quote(ml, "let cKK_RC2   = 17n");
quote(ml, "let cKK_RC4   = 18n");
quote(ml, "let cKK_DES   = 19n");
quote(ml, "let cKK_DES2  = 20n");
quote(ml, "let cKK_DES3  = 21n");
quote(ml, "let cKK_CAST  = 22n");
quote(ml, "let cKK_CAST3  = 23n");
quote(ml, "let cKK_CAST128  = 24n");
quote(ml, "let cKK_RC5   = 25n");
quote(ml, "let cKK_IDEA  = 26n");
quote(ml, "let cKK_SKIPJACK  = 27n");
quote(ml, "let cKK_BATON  = 28n");
quote(ml, "let cKK_JUNIPER  = 29n");
quote(ml, "let cKK_CDMF  = 30n");
quote(ml, "let cKK_AES   = 31n");
quote(ml, "let cKK_BLOWFISH  = 32n");
quote(ml, "let cKK_TWOFISH  = 33n");
quote(ml, "let cKK_SECURID  = 34n");
quote(ml, "let cKK_HOTP  = 35n");
quote(ml, "let cKK_ACTI  = 36n");
quote(ml, "let cKK_CAMELLIA  = 37n");
quote(ml, "let cKK_ARIA  = 38n");
#ifdef __LP64__
quote(ml, "let cKK_VENDOR_DEFINED = 2147483648n");
#else
quote(ml, "let cKK_VENDOR_DEFINED = -2147483648n");
#endif
quote(ml, "let cKC_X_509  = 0n");
quote(ml, "let cKC_X_509_ATTR_CERT = 1n");
quote(ml, "let cKC_WTLS  = 2n");
#ifdef __LP64__
quote(ml, "let cKC_VENDOR_DEFINED = 2147483648n");
#else
quote(ml, "let cKC_VENDOR_DEFINED = -2147483648n");
#endif
quote(ml, "let cK_OTP_FORMAT_DECIMAL   = 0n");
quote(ml, "let cK_OTP_FORMAT_HEXADECIMAL   = 1n");
quote(ml, "let cK_OTP_FORMAT_ALPHANUMERIC   = 2n");
quote(ml, "let cK_OTP_PARAM_IGNORED   = 0n");
quote(ml, "let cK_OTP_PARAM_OPTIONAL   = 1n");
quote(ml, "let cK_OTP_PARAM_MANDATORY   = 2n");
quote(ml, "let cKA_CLASS   = 0n");
quote(ml, "let cKA_TOKEN   = 1n");
quote(ml, "let cKA_PRIVATE   = 2n");
quote(ml, "let cKA_LABEL   = 3n");
quote(ml, "let cKA_APPLICATION   = 16n");
quote(ml, "let cKA_VALUE   = 17n");
quote(ml, "let cKA_OBJECT_ID   = 18n");
quote(ml, "let cKA_CERTIFICATE_TYPE  = 128n");
quote(ml, "let cKA_ISSUER   = 129n");
quote(ml, "let cKA_SERIAL_NUMBER  = 130n");
quote(ml, "let cKA_AC_ISSUER   = 131n");
quote(ml, "let cKA_OWNER   = 132n");
quote(ml, "let cKA_ATTR_TYPES   = 133n");
quote(ml, "let cKA_TRUSTED   = 134n");
quote(ml, "let cKA_CERTIFICATE_CATEGORY = 135n");
quote(ml, "let cKA_JAVA_MIDP_SECURITY_DOMAIN = 136n");
quote(ml, "let cKA_URL    = 137n");
quote(ml, "let cKA_HASH_OF_SUBJECT_PUBLIC_KEY = 138n");
quote(ml, "let cKA_HASH_OF_ISSUER_PUBLIC_KEY = 139n");
quote(ml, "let cKA_CHECK_VALUE   = 144n");
quote(ml, "let cKA_KEY_TYPE   = 256n");
quote(ml, "let cKA_SUBJECT   = 257n");
quote(ml, "let cKA_ID    = 258n");
quote(ml, "let cKA_SENSITIVE   = 259n");
quote(ml, "let cKA_ENCRYPT   = 260n");
quote(ml, "let cKA_DECRYPT   = 261n");
quote(ml, "let cKA_WRAP   = 262n");
quote(ml, "let cKA_UNWRAP   = 263n");
quote(ml, "let cKA_SIGN   = 264n");
quote(ml, "let cKA_SIGN_RECOVER  = 265n");
quote(ml, "let cKA_VERIFY   = 266n");
quote(ml, "let cKA_VERIFY_RECOVER  = 267n");
quote(ml, "let cKA_DERIVE   = 268n");
quote(ml, "let cKA_START_DATE   = 272n");
quote(ml, "let cKA_END_DATE   = 273n");
quote(ml, "let cKA_MODULUS   = 288n");
quote(ml, "let cKA_MODULUS_BITS  = 289n");
quote(ml, "let cKA_PUBLIC_EXPONENT  = 290n");
quote(ml, "let cKA_PRIVATE_EXPONENT  = 291n");
quote(ml, "let cKA_PRIME_1   = 292n");
quote(ml, "let cKA_PRIME_2   = 293n");
quote(ml, "let cKA_EXPONENT_1   = 294n");
quote(ml, "let cKA_EXPONENT_2   = 295n");
quote(ml, "let cKA_COEFFICIENT   = 296n");
quote(ml, "let cKA_PRIME   = 304n");
quote(ml, "let cKA_SUBPRIME   = 305n");
quote(ml, "let cKA_BASE   = 306n");
quote(ml, "let cKA_PRIME_BITS   = 307n");
quote(ml, "let cKA_SUB_PRIME_BITS  = 308n");
quote(ml, "let cKA_VALUE_BITS   = 352n");
quote(ml, "let cKA_VALUE_LEN   = 353n");
quote(ml, "let cKA_EXTRACTABLE   = 354n");
quote(ml, "let cKA_LOCAL   = 355n");
quote(ml, "let cKA_NEVER_EXTRACTABLE  = 356n");
quote(ml, "let cKA_ALWAYS_SENSITIVE  = 357n");
quote(ml, "let cKA_KEY_GEN_MECHANISM  = 358n");
quote(ml, "let cKA_MODIFIABLE   = 368n");
quote(ml, "let cKA_ECDSA_PARAMS  = 384n");
quote(ml, "let cKA_EC_PARAMS   = 384n");
quote(ml, "let cKA_EC_POINT   = 385n");
quote(ml, "let cKA_SECONDARY_AUTH  = 512n");
quote(ml, "let cKA_AUTH_PIN_FLAGS  = 513n");
quote(ml, "let cKA_ALWAYS_AUTHENTICATE  = 514n");
quote(ml, "let cKA_WRAP_WITH_TRUSTED  = 528n");
quote(ml, "let cKA_OTP_FORMAT                   = 544n");
quote(ml, "let cKA_OTP_LENGTH                   = 545n");
quote(ml, "let cKA_OTP_TIME_INTERVAL            = 546n");
quote(ml, "let cKA_OTP_USER_FRIENDLY_MODE       = 547n");
quote(ml, "let cKA_OTP_CHALLENGE_REQUIREMENT    = 548n");
quote(ml, "let cKA_OTP_TIME_REQUIREMENT         = 549n");
quote(ml, "let cKA_OTP_COUNTER_REQUIREMENT      = 550n");
quote(ml, "let cKA_OTP_PIN_REQUIREMENT          = 551n");
quote(ml, "let cKA_OTP_COUNTER                  = 552n");
quote(ml, "let cKA_OTP_TIME                     = 553n");
quote(ml, "let cKA_OTP_USER_IDENTIFIER          = 554n");
quote(ml, "let cKA_OTP_SERVICE_IDENTIFIER       = 555n");
quote(ml, "let cKA_OTP_SERVICE_LOGO             = 556n");
quote(ml, "let cKA_OTP_SERVICE_LOGO_TYPE        = 557n");
quote(ml, "let cKA_HW_FEATURE_TYPE  = 768n");
quote(ml, "let cKA_RESET_ON_INIT  = 769n");
quote(ml, "let cKA_HAS_RESET   = 770n");
quote(ml, "let cKA_PIXEL_X   = 1024n");
quote(ml, "let cKA_PIXEL_Y   = 1025n");
quote(ml, "let cKA_RESOLUTION   = 1026n");
quote(ml, "let cKA_CHAR_ROWS   = 1027n");
quote(ml, "let cKA_CHAR_COLUMNS  = 1028n");
quote(ml, "let cKA_COLOR   = 1029n");
quote(ml, "let cKA_BITS_PER_PIXEL  = 1030n");
quote(ml, "let cKA_CHAR_SETS   = 1152n");
quote(ml, "let cKA_ENCODING_METHODS  = 1153n");
quote(ml, "let cKA_MIME_TYPES   = 1154n");
quote(ml, "let cKA_MECHANISM_TYPE  = 1280n");
quote(ml, "let cKA_REQUIRED_CMS_ATTRIBUTES = 1281n");
quote(ml, "let cKA_DEFAULT_CMS_ATTRIBUTES = 1282n");
quote(ml, "let cKA_SUPPORTED_CMS_ATTRIBUTES = 1283n");
quote(ml, "let cKA_WRAP_TEMPLATE  = 1073742353n");
quote(ml, "let cKA_UNWRAP_TEMPLATE  = 1073742354n");
quote(ml, "let cKA_ALLOWED_MECHANISMS  = 1073743360n");
#if __LP64__
quote(ml, "let cKA_VENDOR_DEFINED  = 2147483648n");
#else
quote(ml, "let cKA_VENDOR_DEFINED  = -2147483648n");
#endif
quote(ml, "let cKM_RSA_PKCS_KEY_PAIR_GEN = 0n");
quote(ml, "let cKM_RSA_PKCS   = 1n");
quote(ml, "let cKM_RSA_9796   = 2n");
quote(ml, "let cKM_RSA_X_509   = 3n");
quote(ml, "let cKM_MD2_RSA_PKCS  = 4n");
quote(ml, "let cKM_MD5_RSA_PKCS  = 5n");
quote(ml, "let cKM_SHA1_RSA_PKCS  = 6n");
quote(ml, "let cKM_RIPEMD128_RSA_PKCS  = 7n");
quote(ml, "let cKM_RIPEMD160_RSA_PKCS  = 8n");
quote(ml, "let cKM_RSA_PKCS_OAEP  = 9n");
quote(ml, "let cKM_RSA_X9_31_KEY_PAIR_GEN = 10n");
quote(ml, "let cKM_RSA_X9_31   = 11n");
quote(ml, "let cKM_SHA1_RSA_X9_31  = 12n");
quote(ml, "let cKM_RSA_PKCS_PSS  = 13n");
quote(ml, "let cKM_SHA1_RSA_PKCS_PSS  = 14n");
quote(ml, "let cKM_DSA_KEY_PAIR_GEN  = 16n");
quote(ml, "let cKM_DSA    = 17n");
quote(ml, "let cKM_DSA_SHA1   = 18n");
quote(ml, "let cKM_DH_PKCS_KEY_PAIR_GEN = 32n");
quote(ml, "let cKM_DH_PKCS_DERIVE  = 33n");
quote(ml, "let cKM_X9_42_DH_KEY_PAIR_GEN = 48n");
quote(ml, "let cKM_X9_42_DH_DERIVE  = 49n");
quote(ml, "let cKM_X9_42_DH_HYBRID_DERIVE = 50n");
quote(ml, "let cKM_X9_42_MQV_DERIVE  = 51n");
quote(ml, "let cKM_SHA256_RSA_PKCS  = 64n");
quote(ml, "let cKM_SHA384_RSA_PKCS  = 65n");
quote(ml, "let cKM_SHA512_RSA_PKCS  = 66n");
quote(ml, "let cKM_SHA256_RSA_PKCS_PSS  = 67n");
quote(ml, "let cKM_SHA384_RSA_PKCS_PSS  = 68n");
quote(ml, "let cKM_SHA512_RSA_PKCS_PSS  = 69n");
quote(ml, "let cKM_SHA224_RSA_PKCS  = 70n");
quote(ml, "let cKM_SHA224_RSA_PKCS_PSS  = 71n");
quote(ml, "let cKM_RC2_KEY_GEN   = 256n");
quote(ml, "let cKM_RC2_ECB   = 257n");
quote(ml, "let cKM_RC2_CBC   = 258n");
quote(ml, "let cKM_RC2_MAC   = 259n");
quote(ml, "let cKM_RC2_MAC_GENERAL  = 260n");
quote(ml, "let cKM_RC2_CBC_PAD   = 261n");
quote(ml, "let cKM_RC4_KEY_GEN   = 272n");
quote(ml, "let cKM_RC4    = 273n");
quote(ml, "let cKM_DES_KEY_GEN   = 288n");
quote(ml, "let cKM_DES_ECB   = 289n");
quote(ml, "let cKM_DES_CBC   = 290n");
quote(ml, "let cKM_DES_MAC   = 291n");
quote(ml, "let cKM_DES_MAC_GENERAL  = 292n");
quote(ml, "let cKM_DES_CBC_PAD   = 293n");
quote(ml, "let cKM_DES2_KEY_GEN  = 304n");
quote(ml, "let cKM_DES3_KEY_GEN  = 305n");
quote(ml, "let cKM_DES3_ECB   = 306n");
quote(ml, "let cKM_DES3_CBC   = 307n");
quote(ml, "let cKM_DES3_MAC   = 308n");
quote(ml, "let cKM_DES3_MAC_GENERAL  = 309n");
quote(ml, "let cKM_DES3_CBC_PAD  = 310n");
quote(ml, "let cKM_CDMF_KEY_GEN  = 320n");
quote(ml, "let cKM_CDMF_ECB   = 321n");
quote(ml, "let cKM_CDMF_CBC   = 322n");
quote(ml, "let cKM_CDMF_MAC   = 323n");
quote(ml, "let cKM_CDMF_MAC_GENERAL  = 324n");
quote(ml, "let cKM_CDMF_CBC_PAD  = 325n");
quote(ml, "let cKM_MD2    = 512n");
quote(ml, "let cKM_MD2_HMAC   = 513n");
quote(ml, "let cKM_MD2_HMAC_GENERAL  = 514n");
quote(ml, "let cKM_MD5    = 528n");
quote(ml, "let cKM_MD5_HMAC   = 529n");
quote(ml, "let cKM_MD5_HMAC_GENERAL  = 530n");
quote(ml, "let cKM_SHA_1   = 544n");
quote(ml, "let cKM_SHA_1_HMAC   = 545n");
quote(ml, "let cKM_SHA_1_HMAC_GENERAL  = 546n");
quote(ml, "let cKM_RIPEMD128   = 560n");
quote(ml, "let cKM_RIPEMD128_HMAC  = 561n");
quote(ml, "let cKM_RIPEMD128_HMAC_GENERAL = 562n");
quote(ml, "let cKM_RIPEMD160   = 576n");
quote(ml, "let cKM_RIPEMD160_HMAC  = 577n");
quote(ml, "let cKM_RIPEMD160_HMAC_GENERAL = 578n");
quote(ml, "let cKM_SHA256   = 592n");
quote(ml, "let cKM_SHA256_HMAC   = 593n");
quote(ml, "let cKM_SHA256_HMAC_GENERAL  = 594n");
quote(ml, "let cKM_SHA384   = 608n");
quote(ml, "let cKM_SHA384_HMAC   = 609n");
quote(ml, "let cKM_SHA384_HMAC_GENERAL  = 610n");
quote(ml, "let cKM_SHA512   = 624n");
quote(ml, "let cKM_SHA512_HMAC   = 625n");
quote(ml, "let cKM_SHA512_HMAC_GENERAL  = 626n");
quote(ml, "let cKM_SHA224   = 597n");
quote(ml, "let cKM_SHA224_HMAC   = 598n");
quote(ml, "let cKM_SHA224_HMAC_GENERAL  = 599n");
quote(ml, "let cKM_SECURID_KEY_GEN  = 640n");
quote(ml, "let cKM_SECURID  = 642n");
quote(ml, "let cKM_HOTP_KEY_GEN  = 656n");
quote(ml, "let cKM_HOTP  = 657n");
quote(ml, "let cKM_ACTI_KEY_GEN  = 672n");
quote(ml, "let cKM_ACTI  = 673n");
quote(ml, "let cKM_CAST_KEY_GEN  = 768n");
quote(ml, "let cKM_CAST_ECB   = 769n");
quote(ml, "let cKM_CAST_CBC   = 770n");
quote(ml, "let cKM_CAST_MAC   = 771n");
quote(ml, "let cKM_CAST_MAC_GENERAL  = 772n");
quote(ml, "let cKM_CAST_CBC_PAD  = 773n");
quote(ml, "let cKM_CAST3_KEY_GEN  = 784n");
quote(ml, "let cKM_CAST3_ECB   = 785n");
quote(ml, "let cKM_CAST3_CBC   = 786n");
quote(ml, "let cKM_CAST3_MAC   = 787n");
quote(ml, "let cKM_CAST3_MAC_GENERAL  = 788n");
quote(ml, "let cKM_CAST3_CBC_PAD  = 789n");
quote(ml, "let cKM_CAST5_KEY_GEN  = 800n");
quote(ml, "let cKM_CAST128_KEY_GEN  = 800n");
quote(ml, "let cKM_CAST5_ECB   = 801n");
quote(ml, "let cKM_CAST128_ECB   = 801n");
quote(ml, "let cKM_CAST5_CBC   = 802n");
quote(ml, "let cKM_CAST128_CBC   = 802n");
quote(ml, "let cKM_CAST5_MAC   = 803n");
quote(ml, "let cKM_CAST128_MAC   = 803n");
quote(ml, "let cKM_CAST5_MAC_GENERAL  = 804n");
quote(ml, "let cKM_CAST128_MAC_GENERAL  = 804n");
quote(ml, "let cKM_CAST5_CBC_PAD  = 805n");
quote(ml, "let cKM_CAST128_CBC_PAD  = 805n");
quote(ml, "let cKM_RC5_KEY_GEN   = 816n");
quote(ml, "let cKM_RC5_ECB   = 817n");
quote(ml, "let cKM_RC5_CBC   = 818n");
quote(ml, "let cKM_RC5_MAC   = 819n");
quote(ml, "let cKM_RC5_MAC_GENERAL  = 820n");
quote(ml, "let cKM_RC5_CBC_PAD   = 821n");
quote(ml, "let cKM_IDEA_KEY_GEN  = 832n");
quote(ml, "let cKM_IDEA_ECB   = 833n");
quote(ml, "let cKM_IDEA_CBC   = 834n");
quote(ml, "let cKM_IDEA_MAC   = 835n");
quote(ml, "let cKM_IDEA_MAC_GENERAL  = 836n");
quote(ml, "let cKM_IDEA_CBC_PAD  = 837n");
quote(ml, "let cKM_GENERIC_SECRET_KEY_GEN = 848n");
quote(ml, "let cKM_CONCATENATE_BASE_AND_KEY = 864n");
quote(ml, "let cKM_CONCATENATE_BASE_AND_DATA = 866n");
quote(ml, "let cKM_CONCATENATE_DATA_AND_BASE = 867n");
quote(ml, "let cKM_XOR_BASE_AND_DATA  = 868n");
quote(ml, "let cKM_EXTRACT_KEY_FROM_KEY = 869n");
quote(ml, "let cKM_SSL3_PRE_MASTER_KEY_GEN = 880n");
quote(ml, "let cKM_SSL3_MASTER_KEY_DERIVE = 881n");
quote(ml, "let cKM_SSL3_KEY_AND_MAC_DERIVE = 882n");
quote(ml, "let cKM_SSL3_MASTER_KEY_DERIVE_DH = 883n");
quote(ml, "let cKM_TLS_PRE_MASTER_KEY_GEN = 884n");
quote(ml, "let cKM_TLS_MASTER_KEY_DERIVE = 885n");
quote(ml, "let cKM_TLS_KEY_AND_MAC_DERIVE = 886n");
quote(ml, "let cKM_TLS_MASTER_KEY_DERIVE_DH = 887n");
quote(ml, "let cKM_TLS_PRF  = 888n");
quote(ml, "let cKM_SSL3_MD5_MAC  = 896n");
quote(ml, "let cKM_SSL3_SHA1_MAC  = 897n");
quote(ml, "let cKM_MD5_KEY_DERIVATION  = 912n");
quote(ml, "let cKM_MD2_KEY_DERIVATION  = 913n");
quote(ml, "let cKM_SHA1_KEY_DERIVATION  = 914n");
quote(ml, "let cKM_SHA256_KEY_DERIVATION  = 915n");
quote(ml, "let cKM_SHA384_KEY_DERIVATION  = 916n");
quote(ml, "let cKM_SHA512_KEY_DERIVATION  = 917n");
quote(ml, "let cKM_SHA224_KEY_DERIVATION  = 918n");
quote(ml, "let cKM_PBE_MD2_DES_CBC  = 928n");
quote(ml, "let cKM_PBE_MD5_DES_CBC  = 929n");
quote(ml, "let cKM_PBE_MD5_CAST_CBC  = 930n");
quote(ml, "let cKM_PBE_MD5_CAST3_CBC  = 931n");
quote(ml, "let cKM_PBE_MD5_CAST5_CBC  = 932n");
quote(ml, "let cKM_PBE_MD5_CAST128_CBC  = 932n");
quote(ml, "let cKM_PBE_SHA1_CAST5_CBC  = 933n");
quote(ml, "let cKM_PBE_SHA1_CAST128_CBC = 933n");
quote(ml, "let cKM_PBE_SHA1_RC4_128  = 934n");
quote(ml, "let cKM_PBE_SHA1_RC4_40  = 935n");
quote(ml, "let cKM_PBE_SHA1_DES3_EDE_CBC = 936n");
quote(ml, "let cKM_PBE_SHA1_DES2_EDE_CBC = 937n");
quote(ml, "let cKM_PBE_SHA1_RC2_128_CBC = 938n");
quote(ml, "let cKM_PBE_SHA1_RC2_40_CBC  = 939n");
quote(ml, "let cKM_PKCS5_PBKD2   = 944n");
quote(ml, "let cKM_PBA_SHA1_WITH_SHA1_HMAC = 960n");
quote(ml, "let cKM_WTLS_PRE_MASTER_KEY_GEN = 976n");
quote(ml, "let cKM_WTLS_MASTER_KEY_DERIVE = 977n");
quote(ml, "let cKM_WTLS_MASTER_KEY_DERIVE_DH_ECC = 978n");
quote(ml, "let cKM_WTLS_PRF = 979n");
quote(ml, "let cKM_WTLS_SERVER_KEY_AND_MAC_DERIVE = 980n");
quote(ml, "let cKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE = 981n");
quote(ml, "let cKM_KEY_WRAP_LYNKS  = 1024n");
quote(ml, "let cKM_KEY_WRAP_SET_OAEP  = 1025n");
quote(ml, "let cKM_CMS_SIG = 1280n");
quote(ml, "let cKM_KIP_DERIVE = 1296n");
quote(ml, "let cKM_KIP_WRAP = 1297n");
quote(ml, "let cKM_KIP_MAC = 1298n");
quote(ml, "let cKM_CAMELLIA_KEY_GEN = 1360n");
quote(ml, "let cKM_CAMELLIA_ECB = 1361n");
quote(ml, "let cKM_CAMELLIA_CBC = 1362n");
quote(ml, "let cKM_CAMELLIA_MAC = 1363n");
quote(ml, "let cKM_CAMELLIA_MAC_GENERAL = 1364n");
quote(ml, "let cKM_CAMELLIA_CBC_PAD = 1365n");
quote(ml, "let cKM_CAMELLIA_ECB_ENCRYPT_DATA = 1366n");
quote(ml, "let cKM_CAMELLIA_CBC_ENCRYPT_DATA = 1367n");
quote(ml, "let cKM_CAMELLIA_CTR = 1368n");
quote(ml, "let cKM_ARIA_KEY_GEN = 1376n");
quote(ml, "let cKM_ARIA_ECB = 1377n");
quote(ml, "let cKM_ARIA_CBC = 1378n");
quote(ml, "let cKM_ARIA_MAC = 1379n");
quote(ml, "let cKM_ARIA_MAC_GENERAL = 1380n");
quote(ml, "let cKM_ARIA_CBC_PAD = 1381n");
quote(ml, "let cKM_ARIA_ECB_ENCRYPT_DATA = 1382n");
quote(ml, "let cKM_ARIA_CBC_ENCRYPT_DATA = 1383n");
quote(ml, "let cKM_SKIPJACK_KEY_GEN  = 4096n");
quote(ml, "let cKM_SKIPJACK_ECB64  = 4097n");
quote(ml, "let cKM_SKIPJACK_CBC64  = 4098n");
quote(ml, "let cKM_SKIPJACK_OFB64  = 4099n");
quote(ml, "let cKM_SKIPJACK_CFB64  = 4100n");
quote(ml, "let cKM_SKIPJACK_CFB32  = 4101n");
quote(ml, "let cKM_SKIPJACK_CFB16  = 4102n");
quote(ml, "let cKM_SKIPJACK_CFB8  = 4103n");
quote(ml, "let cKM_SKIPJACK_WRAP  = 4104n");
quote(ml, "let cKM_SKIPJACK_PRIVATE_WRAP = 4105n");
quote(ml, "let cKM_SKIPJACK_RELAYX  = 4106n");
quote(ml, "let cKM_KEA_KEY_PAIR_GEN  = 4112n");
quote(ml, "let cKM_KEA_KEY_DERIVE  = 4113n");
quote(ml, "let cKM_FORTEZZA_TIMESTAMP  = 4128n");
quote(ml, "let cKM_BATON_KEY_GEN  = 4144n");
quote(ml, "let cKM_BATON_ECB128  = 4145n");
quote(ml, "let cKM_BATON_ECB96   = 4146n");
quote(ml, "let cKM_BATON_CBC128  = 4147n");
quote(ml, "let cKM_BATON_COUNTER  = 4148n");
quote(ml, "let cKM_BATON_SHUFFLE  = 4149n");
quote(ml, "let cKM_BATON_WRAP   = 4150n");
quote(ml, "let cKM_ECDSA_KEY_PAIR_GEN  = 4160n");
quote(ml, "let cKM_EC_KEY_PAIR_GEN  = 4160n");
quote(ml, "let cKM_ECDSA   = 4161n");
quote(ml, "let cKM_ECDSA_SHA1   = 4162n");
quote(ml, "let cKM_ECDH1_DERIVE  = 4176n");
quote(ml, "let cKM_ECDH1_COFACTOR_DERIVE = 4177n");
quote(ml, "let cKM_ECMQV_DERIVE  = 4178n");
quote(ml, "let cKM_JUNIPER_KEY_GEN  = 4192n");
quote(ml, "let cKM_JUNIPER_ECB128  = 4193n");
quote(ml, "let cKM_JUNIPER_CBC128  = 4194n");
quote(ml, "let cKM_JUNIPER_COUNTER  = 4195n");
quote(ml, "let cKM_JUNIPER_SHUFFLE  = 4196n");
quote(ml, "let cKM_JUNIPER_WRAP  = 4197n");
quote(ml, "let cKM_FASTHASH   = 4208n");
quote(ml, "let cKM_AES_KEY_GEN   = 4224n");
quote(ml, "let cKM_AES_ECB   = 4225n");
quote(ml, "let cKM_AES_CBC   = 4226n");
quote(ml, "let cKM_AES_MAC   = 4227n");
quote(ml, "let cKM_AES_MAC_GENERAL  = 4228n");
quote(ml, "let cKM_AES_CBC_PAD   = 4229n");
quote(ml, "let cKM_AES_CTR   = 4230n");
quote(ml, "let cKM_BLOWFISH_KEY_GEN = 4240n");
quote(ml, "let cKM_BLOWFISH_CBC = 4241n");
quote(ml, "let cKM_TWOFISH_KEY_GEN = 4242n");
quote(ml, "let cKM_TWOFISH_CBC = 4243n");
quote(ml, "let cKM_DES_ECB_ENCRYPT_DATA = 4352n");
quote(ml, "let cKM_DES_CBC_ENCRYPT_DATA = 4353n");
quote(ml, "let cKM_DES3_ECB_ENCRYPT_DATA = 4354n");
quote(ml, "let cKM_DES3_CBC_ENCRYPT_DATA = 4355n");
quote(ml, "let cKM_AES_ECB_ENCRYPT_DATA = 4356n");
quote(ml, "let cKM_AES_CBC_ENCRYPT_DATA = 4357n");
quote(ml, "let cKM_DSA_PARAMETER_GEN  = 8192n");
quote(ml, "let cKM_DH_PKCS_PARAMETER_GEN = 8193n");
quote(ml, "let cKM_X9_42_DH_PARAMETER_GEN = 8194n");
#if __LP64__
quote(ml, "let cKM_VENDOR_DEFINED  = 2147483648n");
#else
quote(ml, "let cKM_VENDOR_DEFINED  = -2147483648n");
#endif
quote(ml, "let cKF_HW   = 1n");
quote(ml, "let cKF_ENCRYPT  = 256n");
quote(ml, "let cKF_DECRYPT  = 512n");
quote(ml, "let cKF_DIGEST  = 1024n");
quote(ml, "let cKF_SIGN  = 2048n");
quote(ml, "let cKF_SIGN_RECOVER = 4096n");
quote(ml, "let cKF_VERIFY  = 8192n");
quote(ml, "let cKF_VERIFY_RECOVER = 16384n");
quote(ml, "let cKF_GENERATE  = 32768n");
quote(ml, "let cKF_GENERATE_KEY_PAIR = 65536n");
quote(ml, "let cKF_WRAP  = 131072n");
quote(ml, "let cKF_UNWRAP  = 262144n");
quote(ml, "let cKF_DERIVE  = 524288n");
quote(ml, "let cKF_EC_F_P  = 1048576n");
quote(ml, "let cKF_EC_F_2M  = 2097152n");
quote(ml, "let cKF_EC_ECPARAMETERS  = 4194304n");
quote(ml, "let cKF_EC_NAMEDCURVE  = 8388608n");
quote(ml, "let cKF_EC_UNCOMPRESS  = 16777216n");
quote(ml, "let cKF_EC_COMPRESS  = 33554432n");
#if __LP64__
quote(ml, "let cKF_EXTENSION  = 2147483648n");
#else
quote(ml, "let cKF_EXTENSION  = -2147483648n");
#endif
quote(ml, "let cKF_DONT_BLOCK    = 1n");
quote(ml, "let cKF_LIBRARY_CANT_CREATE_OS_THREADS = 1n");
quote(ml, "let cKF_OS_LOCKING_OK   = 2n");
quote(ml, "let cKR_OK     = 0n");
quote(ml, "let cKR_CANCEL    = 1n");
quote(ml, "let cKR_HOST_MEMORY    = 2n");
quote(ml, "let cKR_SLOT_ID_INVALID   = 3n");
quote(ml, "let cKR_GENERAL_ERROR   = 5n");
quote(ml, "let cKR_FUNCTION_FAILED   = 6n");
quote(ml, "let cKR_ARGUMENTS_BAD   = 7n");
quote(ml, "let cKR_NO_EVENT    = 8n");
quote(ml, "let cKR_NEED_TO_CREATE_THREADS  = 9n");
quote(ml, "let cKR_CANT_LOCK    = 10n");
quote(ml, "let cKR_ATTRIBUTE_READ_ONLY   = 16n");
quote(ml, "let cKR_ATTRIBUTE_SENSITIVE   = 17n");
quote(ml, "let cKR_ATTRIBUTE_TYPE_INVALID  = 18n");
quote(ml, "let cKR_ATTRIBUTE_VALUE_INVALID  = 19n");
quote(ml, "let cKR_DATA_INVALID   = 32n");
quote(ml, "let cKR_DATA_LEN_RANGE   = 33n");
quote(ml, "let cKR_DEVICE_ERROR   = 48n");
quote(ml, "let cKR_DEVICE_MEMORY   = 49n");
quote(ml, "let cKR_DEVICE_REMOVED   = 50n");
quote(ml, "let cKR_ENCRYPTED_DATA_INVALID  = 64n");
quote(ml, "let cKR_ENCRYPTED_DATA_LEN_RANGE  = 65n");
quote(ml, "let cKR_FUNCTION_CANCELED   = 80n");
quote(ml, "let cKR_FUNCTION_NOT_PARALLEL  = 81n");
quote(ml, "let cKR_FUNCTION_NOT_SUPPORTED  = 84n");
quote(ml, "let cKR_KEY_HANDLE_INVALID   = 96n");
quote(ml, "let cKR_KEY_SIZE_RANGE   = 98n");
quote(ml, "let cKR_KEY_TYPE_INCONSISTENT  = 99n");
quote(ml, "let cKR_KEY_NOT_NEEDED   = 100n");
quote(ml, "let cKR_KEY_CHANGED    = 101n");
quote(ml, "let cKR_KEY_NEEDED    = 102n");
quote(ml, "let cKR_KEY_INDIGESTIBLE   = 103n");
quote(ml, "let cKR_KEY_FUNCTION_NOT_PERMITTED  = 104n");
quote(ml, "let cKR_KEY_NOT_WRAPPABLE   = 105n");
quote(ml, "let cKR_KEY_UNEXTRACTABLE   = 106n");
quote(ml, "let cKR_MECHANISM_INVALID   = 112n");
quote(ml, "let cKR_MECHANISM_PARAM_INVALID  = 113n");
quote(ml, "let cKR_OBJECT_HANDLE_INVALID  = 130n");
quote(ml, "let cKR_OPERATION_ACTIVE   = 144n");
quote(ml, "let cKR_OPERATION_NOT_INITIALIZED  = 145n");
quote(ml, "let cKR_PIN_INCORRECT   = 160n");
quote(ml, "let cKR_PIN_INVALID    = 161n");
quote(ml, "let cKR_PIN_LEN_RANGE   = 162n");
quote(ml, "let cKR_PIN_EXPIRED    = 163n");
quote(ml, "let cKR_PIN_LOCKED    = 164n");
quote(ml, "let cKR_SESSION_CLOSED   = 176n");
quote(ml, "let cKR_SESSION_COUNT   = 177n");
quote(ml, "let cKR_SESSION_HANDLE_INVALID  = 179n");
quote(ml, "let cKR_SESSION_PARALLEL_NOT_SUPPORTED = 180n");
quote(ml, "let cKR_SESSION_READ_ONLY   = 181n");
quote(ml, "let cKR_SESSION_EXISTS   = 182n");
quote(ml, "let cKR_SESSION_READ_ONLY_EXISTS  = 183n");
quote(ml, "let cKR_SESSION_READ_WRITE_SO_EXISTS = 184n");
quote(ml, "let cKR_SIGNATURE_INVALID   = 192n");
quote(ml, "let cKR_SIGNATURE_LEN_RANGE   = 193n");
quote(ml, "let cKR_TEMPLATE_INCOMPLETE   = 208n");
quote(ml, "let cKR_TEMPLATE_INCONSISTENT  = 209n");
quote(ml, "let cKR_TOKEN_NOT_PRESENT   = 224n");
quote(ml, "let cKR_TOKEN_NOT_RECOGNIZED  = 225n");
quote(ml, "let cKR_TOKEN_WRITE_PROTECTED  = 226n");
quote(ml, "let cKR_UNWRAPPING_KEY_HANDLE_INVALID = 240n");
quote(ml, "let cKR_UNWRAPPING_KEY_SIZE_RANGE  = 241n");
quote(ml, "let cKR_UNWRAPPING_KEY_TYPE_INCONSISTENT = 242n");
quote(ml, "let cKR_USER_ALREADY_LOGGED_IN  = 256n");
quote(ml, "let cKR_USER_NOT_LOGGED_IN   = 257n");
quote(ml, "let cKR_USER_PIN_NOT_INITIALIZED  = 258n");
quote(ml, "let cKR_USER_TYPE_INVALID   = 259n");
quote(ml, "let cKR_USER_ANOTHER_ALREADY_LOGGED_IN = 260n");
quote(ml, "let cKR_USER_TOO_MANY_TYPES   = 261n");
quote(ml, "let cKR_WRAPPED_KEY_INVALID   = 272n");
quote(ml, "let cKR_WRAPPED_KEY_LEN_RANGE  = 274n");
quote(ml, "let cKR_WRAPPING_KEY_HANDLE_INVALID  = 275n");
quote(ml, "let cKR_WRAPPING_KEY_SIZE_RANGE  = 276n");
quote(ml, "let cKR_WRAPPING_KEY_TYPE_INCONSISTENT = 277n");
quote(ml, "let cKR_RANDOM_SEED_NOT_SUPPORTED  = 288n");
quote(ml, "let cKR_RANDOM_NO_RNG   = 289n");
quote(ml, "let cKR_DOMAIN_PARAMS_INVALID  = 304n");
quote(ml, "let cKR_BUFFER_TOO_SMALL   = 336n");
quote(ml, "let cKR_SAVED_STATE_INVALID   = 352n");
quote(ml, "let cKR_INFORMATION_SENSITIVE  = 368n");
quote(ml, "let cKR_STATE_UNSAVEABLE   = 384n");
quote(ml, "let cKR_CRYPTOKI_NOT_INITIALIZED  = 400n");
quote(ml, "let cKR_CRYPTOKI_ALREADY_INITIALIZED = 401n");
quote(ml, "let cKR_MUTEX_BAD    = 416n");
quote(ml, "let cKR_MUTEX_NOT_LOCKED   = 417n");
quote(ml, "let cKR_NEW_PIN_MODE   = 432n");
quote(ml, "let cKR_NEXT_OTP   = 433n");
quote(ml, "let cKR_FUNCTION_REJECTED   = 512n");
#if __LP64__
quote(ml, "let cKR_VENDOR_DEFINED   = 2147483648n");
#else
quote(ml, "let cKR_VENDOR_DEFINED   = -2147483648n");
#endif
quote(ml, "let cK_FALSE = 0n");
quote(ml, "let cK_TRUE = 1n");
quote(ml, "let fALSE = 0n");
quote(ml, "let tRUE = 1n");
quote(ml, "let nULL_PTR = 0n");

quote(mli, "val false_ : char array");
quote(mli, "val true_ : char array");
quote(ml, "let false_ = Array.make 1 (Char.chr 0)");
quote(ml, "let true_ = Array.make 1 (Char.chr 1)");

quote(ml, "(* Helpers for information printing *)\n");
quote(ml, "let match_cKR_value a = match a with");
quote(ml, "  0n -> \"cKR_OK\"");
quote(ml, "| 1n -> \"cKR_CANCEL\"");
quote(ml, "| 2n -> \"cKR_HOST_MEMORY\"");
quote(ml, "| 3n -> \"cKR_SLOT_ID_INVALID\"");
quote(ml, "| 5n -> \"cKR_GENERAL_ERROR\"");
quote(ml, "| 6n -> \"cKR_FUNCTION_FAILED\"");
quote(ml, "| 7n -> \"cKR_ARGUMENTS_BAD\"");
quote(ml, "| 8n -> \"cKR_NO_EVENT\"");
quote(ml, "| 9n -> \"cKR_NEED_TO_CREATE_THREADS\"");
quote(ml, "| 10n -> \"cKR_CANT_LOCK\"");
quote(ml, "| 16n -> \"cKR_ATTRIBUTE_READ_ONLY\"");
quote(ml, "| 17n -> \"cKR_ATTRIBUTE_SENSITIVE\"");
quote(ml, "| 18n -> \"cKR_ATTRIBUTE_TYPE_INVALID\"");
quote(ml, "| 19n -> \"cKR_ATTRIBUTE_VALUE_INVALID\"");
quote(ml, "| 32n -> \"cKR_DATA_INVALID\"");
quote(ml, "| 33n -> \"cKR_DATA_LEN_RANGE\"");
quote(ml, "| 48n -> \"cKR_DEVICE_ERROR\"");
quote(ml, "| 49n -> \"cKR_DEVICE_MEMORY\"");
quote(ml, "| 50n -> \"cKR_DEVICE_REMOVED\"");
quote(ml, "| 64n -> \"cKR_ENCRYPTED_DATA_INVALID\"");
quote(ml, "| 65n -> \"cKR_ENCRYPTED_DATA_LEN_RANGE\"");
quote(ml, "| 80n -> \"cKR_FUNCTION_CANCELED\"");
quote(ml, "| 81n -> \"cKR_FUNCTION_NOT_PARALLEL\"");
quote(ml, "| 84n -> \"cKR_FUNCTION_NOT_SUPPORTED\"");
quote(ml, "| 96n -> \"cKR_KEY_HANDLE_INVALID\"");
quote(ml, "| 98n -> \"cKR_KEY_SIZE_RANGE\"");
quote(ml, "| 99n -> \"cKR_KEY_TYPE_INCONSISTENT\"");
quote(ml, "| 100n -> \"cKR_KEY_NOT_NEEDED\"");
quote(ml, "| 101n -> \"cKR_KEY_CHANGED\"");
quote(ml, "| 102n -> \"cKR_KEY_NEEDED\"");
quote(ml, "| 103n -> \"cKR_KEY_INDIGESTIBLE\"");
quote(ml, "| 104n -> \"cKR_KEY_FUNCTION_NOT_PERMITTED\"");
quote(ml, "| 105n -> \"cKR_KEY_NOT_WRAPPABLE\"");
quote(ml, "| 106n -> \"cKR_KEY_UNEXTRACTABLE\"");
quote(ml, "| 112n -> \"cKR_MECHANISM_INVALID\"");
quote(ml, "| 113n -> \"cKR_MECHANISM_PARAM_INVALID\"");
quote(ml, "| 130n -> \"cKR_OBJECT_HANDLE_INVALID\"");
quote(ml, "| 144n -> \"cKR_OPERATION_ACTIVE\"");
quote(ml, "| 145n -> \"cKR_OPERATION_NOT_INITIALIZED\"");
quote(ml, "| 160n -> \"cKR_PIN_INCORRECT\"");
quote(ml, "| 161n -> \"cKR_PIN_INVALID\"");
quote(ml, "| 162n -> \"cKR_PIN_LEN_RANGE\"");
quote(ml, "| 163n -> \"cKR_PIN_EXPIRED\"");
quote(ml, "| 164n -> \"cKR_PIN_LOCKED\"");
quote(ml, "| 176n -> \"cKR_SESSION_CLOSED\"");
quote(ml, "| 177n -> \"cKR_SESSION_COUNT\"");
quote(ml, "| 179n -> \"cKR_SESSION_HANDLE_INVALID\"");
quote(ml, "| 180n -> \"cKR_SESSION_PARALLEL_NOT_SUPPORTED\"");
quote(ml, "| 181n -> \"cKR_SESSION_READ_ONLY\"");
quote(ml, "| 182n -> \"cKR_SESSION_EXISTS\"");
quote(ml, "| 183n -> \"cKR_SESSION_READ_ONLY_EXISTS\"");
quote(ml, "| 184n -> \"cKR_SESSION_READ_WRITE_SO_EXISTS\"");
quote(ml, "| 192n -> \"cKR_SIGNATURE_INVALID\"");
quote(ml, "| 193n -> \"cKR_SIGNATURE_LEN_RANGE\"");
quote(ml, "| 208n -> \"cKR_TEMPLATE_INCOMPLETE\"");
quote(ml, "| 209n -> \"cKR_TEMPLATE_INCONSISTENT\"");
quote(ml, "| 224n -> \"cKR_TOKEN_NOT_PRESENT\"");
quote(ml, "| 225n -> \"cKR_TOKEN_NOT_RECOGNIZED\"");
quote(ml, "| 226n -> \"cKR_TOKEN_WRITE_PROTECTED\"");
quote(ml, "| 240n -> \"cKR_UNWRAPPING_KEY_HANDLE_INVALID\"");
quote(ml, "| 241n -> \"cKR_UNWRAPPING_KEY_SIZE_RANGE\"");
quote(ml, "| 242n -> \"cKR_UNWRAPPING_KEY_TYPE_INCONSISTENT\"");
quote(ml, "| 256n -> \"cKR_USER_ALREADY_LOGGED_IN\"");
quote(ml, "| 257n -> \"cKR_USER_NOT_LOGGED_IN\"");
quote(ml, "| 258n -> \"cKR_USER_PIN_NOT_INITIALIZED\"");
quote(ml, "| 259n -> \"cKR_USER_TYPE_INVALID\"");
quote(ml, "| 260n -> \"cKR_USER_ANOTHER_ALREADY_LOGGED_IN\"");
quote(ml, "| 261n -> \"cKR_USER_TOO_MANY_TYPES\"");
quote(ml, "| 272n -> \"cKR_WRAPPED_KEY_INVALID\"");
quote(ml, "| 274n -> \"cKR_WRAPPED_KEY_LEN_RANGE\"");
quote(ml, "| 275n -> \"cKR_WRAPPING_KEY_HANDLE_INVALID\"");
quote(ml, "| 276n -> \"cKR_WRAPPING_KEY_SIZE_RANGE\"");
quote(ml, "| 277n -> \"cKR_WRAPPING_KEY_TYPE_INCONSISTENT\"");
quote(ml, "| 288n -> \"cKR_RANDOM_SEED_NOT_SUPPORTED\"");
quote(ml, "| 289n -> \"cKR_RANDOM_NO_RNG\"");
quote(ml, "| 304n -> \"cKR_DOMAIN_PARAMS_INVALID\"");
quote(ml, "| 336n -> \"cKR_BUFFER_TOO_SMALL\"");
quote(ml, "| 352n -> \"cKR_SAVED_STATE_INVALID\"");
quote(ml, "| 368n -> \"cKR_INFORMATION_SENSITIVE\"");
quote(ml, "| 384n -> \"cKR_STATE_UNSAVEABLE\"");
quote(ml, "| 400n -> \"cKR_CRYPTOKI_NOT_INITIALIZED\"");
quote(ml, "| 401n -> \"cKR_CRYPTOKI_ALREADY_INITIALIZED\"");
quote(ml, "| 416n -> \"cKR_MUTEX_BAD\"");
quote(ml, "| 417n -> \"cKR_MUTEX_NOT_LOCKED\"");
quote(ml, "| 432n -> \"cKR_NEW_PIN_MODE\"");
quote(ml, "| 433n -> \"cKR_NEXT_OTP\"");
quote(ml, "| 512n -> \"cKR_FUNCTION_REJECTED\"");
#if __LP64__
quote(ml, "| 2147483648n -> \"cKR_VENDOR_DEFINED\"");
#else
quote(ml, "| -2147483648n -> \"cKR_VENDOR_DEFINED\"");
#endif
quote(ml, "| _ -> \"cKR_UNKNOWN!\"");

quote(ml, "let match_cKM_value a = match a with");
quote(ml, "  0n -> \"cKM_RSA_PKCS_KEY_PAIR_GEN\"");
quote(ml, "| 1n -> \"cKM_RSA_PKCS\"");
quote(ml, "| 2n -> \"cKM_RSA_9796\"");
quote(ml, "| 3n -> \"cKM_RSA_X_509\"");
quote(ml, "| 4n -> \"cKM_MD2_RSA_PKCS\"");
quote(ml, "| 5n -> \"cKM_MD5_RSA_PKCS\"");
quote(ml, "| 6n -> \"cKM_SHA1_RSA_PKCS\"");
quote(ml, "| 7n -> \"cKM_RIPEMD128_RSA_PKCS\"");
quote(ml, "| 8n -> \"cKM_RIPEMD160_RSA_PKCS\"");
quote(ml, "| 9n -> \"cKM_RSA_PKCS_OAEP\"");
quote(ml, "| 10n -> \"cKM_RSA_X9_31_KEY_PAIR_GEN\"");
quote(ml, "| 11n -> \"cKM_RSA_X9_31\"");
quote(ml, "| 12n -> \"cKM_SHA1_RSA_X9_31\"");
quote(ml, "| 13n -> \"cKM_RSA_PKCS_PSS\"");
quote(ml, "| 14n -> \"cKM_SHA1_RSA_PKCS_PSS\"");
quote(ml, "| 16n -> \"cKM_DSA_KEY_PAIR_GEN\"");
quote(ml, "| 17n -> \"cKM_DSA\"");
quote(ml, "| 18n -> \"cKM_DSA_SHA1\"");
quote(ml, "| 32n -> \"cKM_DH_PKCS_KEY_PAIR_GEN\"");
quote(ml, "| 33n -> \"cKM_DH_PKCS_DERIVE\"");
quote(ml, "| 48n -> \"cKM_X9_42_DH_KEY_PAIR_GEN\"");
quote(ml, "| 49n -> \"cKM_X9_42_DH_DERIVE\"");
quote(ml, "| 50n -> \"cKM_X9_42_DH_HYBRID_DERIVE\"");
quote(ml, "| 51n -> \"cKM_X9_42_MQV_DERIVE\"");
quote(ml, "| 64n -> \"cKM_SHA256_RSA_PKCS\"");
quote(ml, "| 65n -> \"cKM_SHA384_RSA_PKCS\"");
quote(ml, "| 66n -> \"cKM_SHA512_RSA_PKCS\"");
quote(ml, "| 67n -> \"cKM_SHA256_RSA_PKCS_PSS\"");
quote(ml, "| 68n -> \"cKM_SHA384_RSA_PKCS_PSS\"");
quote(ml, "| 69n -> \"cKM_SHA512_RSA_PKCS_PSS\"");
quote(ml, "| 70n -> \"cKM_SHA224_RSA_PKCS\"");
quote(ml, "| 71n -> \"cKM_SHA224_RSA_PKCS_PSS\"");
quote(ml, "| 256n -> \"cKM_RC2_KEY_GEN\"");
quote(ml, "| 257n -> \"cKM_RC2_ECB\"");
quote(ml, "| 258n -> \"cKM_RC2_CBC\"");
quote(ml, "| 259n -> \"cKM_RC2_MAC\"");
quote(ml, "| 260n -> \"cKM_RC2_MAC_GENERAL\"");
quote(ml, "| 261n -> \"cKM_RC2_CBC_PAD\"");
quote(ml, "| 272n -> \"cKM_RC4_KEY_GEN\"");
quote(ml, "| 273n -> \"cKM_RC4\"");
quote(ml, "| 288n -> \"cKM_DES_KEY_GEN\"");
quote(ml, "| 289n -> \"cKM_DES_ECB\"");
quote(ml, "| 290n -> \"cKM_DES_CBC\"");
quote(ml, "| 291n -> \"cKM_DES_MAC\"");
quote(ml, "| 292n -> \"cKM_DES_MAC_GENERAL\"");
quote(ml, "| 293n -> \"cKM_DES_CBC_PAD\"");
quote(ml, "| 304n -> \"cKM_DES2_KEY_GEN\"");
quote(ml, "| 305n -> \"cKM_DES3_KEY_GEN\"");
quote(ml, "| 306n -> \"cKM_DES3_ECB\"");
quote(ml, "| 307n -> \"cKM_DES3_CBC\"");
quote(ml, "| 308n -> \"cKM_DES3_MAC\"");
quote(ml, "| 309n -> \"cKM_DES3_MAC_GENERAL\"");
quote(ml, "| 310n -> \"cKM_DES3_CBC_PAD\"");
quote(ml, "| 320n -> \"cKM_CDMF_KEY_GEN\"");
quote(ml, "| 321n -> \"cKM_CDMF_ECB\"");
quote(ml, "| 322n -> \"cKM_CDMF_CBC\"");
quote(ml, "| 323n -> \"cKM_CDMF_MAC\"");
quote(ml, "| 324n -> \"cKM_CDMF_MAC_GENERAL\"");
quote(ml, "| 325n -> \"cKM_CDMF_CBC_PAD\"");
quote(ml, "| 512n -> \"cKM_MD2\"");
quote(ml, "| 513n -> \"cKM_MD2_HMAC\"");
quote(ml, "| 514n -> \"cKM_MD2_HMAC_GENERAL\"");
quote(ml, "| 528n -> \"cKM_MD5\"");
quote(ml, "| 529n -> \"cKM_MD5_HMAC\"");
quote(ml, "| 530n -> \"cKM_MD5_HMAC_GENERAL\"");
quote(ml, "| 544n -> \"cKM_SHA_1\"");
quote(ml, "| 545n -> \"cKM_SHA_1_HMAC\"");
quote(ml, "| 546n -> \"cKM_SHA_1_HMAC_GENERAL\"");
quote(ml, "| 560n -> \"cKM_RIPEMD128\"");
quote(ml, "| 561n -> \"cKM_RIPEMD128_HMAC\"");
quote(ml, "| 562n -> \"cKM_RIPEMD128_HMAC_GENERAL\"");
quote(ml, "| 576n -> \"cKM_RIPEMD160\"");
quote(ml, "| 577n -> \"cKM_RIPEMD160_HMAC\"");
quote(ml, "| 578n -> \"cKM_RIPEMD160_HMAC_GENERAL\"");
quote(ml, "| 592n -> \"cKM_SHA256\"");
quote(ml, "| 593n -> \"cKM_SHA256_HMAC\"");
quote(ml, "| 594n -> \"cKM_SHA256_HMAC_GENERAL\"");
quote(ml, "| 597n -> \"cKM_SHA224\"");
quote(ml, "| 598n -> \"cKM_SHA224_HMAC\"");
quote(ml, "| 599n -> \"cKM_SHA224_HMAC_GENERAL\"");
quote(ml, "| 608n -> \"cKM_SHA384\"");
quote(ml, "| 609n -> \"cKM_SHA384_HMAC\"");
quote(ml, "| 610n -> \"cKM_SHA384_HMAC_GENERAL\"");
quote(ml, "| 624n -> \"cKM_SHA512\"");
quote(ml, "| 625n -> \"cKM_SHA512_HMAC\"");
quote(ml, "| 626n -> \"cKM_SHA512_HMAC_GENERAL\"");
quote(ml, "| 640n -> \"cKM_SECURID_KEY_GEN\"");
quote(ml, "| 642n -> \"cKM_SECURID\"");
quote(ml, "| 656n -> \"cKM_HOTP_KEY_GEN\"");
quote(ml, "| 657n -> \"cKM_HOTP\"");
quote(ml, "| 672n -> \"cKM_ACTI_KEY_GEN\"");
quote(ml, "| 673n -> \"cKM_ACTI\"");
quote(ml, "| 768n -> \"cKM_CAST_KEY_GEN\"");
quote(ml, "| 769n -> \"cKM_CAST_ECB\"");
quote(ml, "| 770n -> \"cKM_CAST_CBC\"");
quote(ml, "| 771n -> \"cKM_CAST_MAC\"");
quote(ml, "| 772n -> \"cKM_CAST_MAC_GENERAL\"");
quote(ml, "| 773n -> \"cKM_CAST_CBC_PAD\"");
quote(ml, "| 784n -> \"cKM_CAST3_KEY_GEN\"");
quote(ml, "| 785n -> \"cKM_CAST3_ECB\"");
quote(ml, "| 786n -> \"cKM_CAST3_CBC\"");
quote(ml, "| 787n -> \"cKM_CAST3_MAC\"");
quote(ml, "| 788n -> \"cKM_CAST3_MAC_GENERAL\"");
quote(ml, "| 789n -> \"cKM_CAST3_CBC_PAD\"");
quote(ml, "| 800n -> \"cKM_CAST5_KEY_GEN\"");
quote(ml, "| 801n -> \"cKM_CAST5_ECB\"");
quote(ml, "| 802n -> \"cKM_CAST5_CBC\"");
quote(ml, "| 803n -> \"cKM_CAST5_MAC\"");
quote(ml, "| 804n -> \"cKM_CAST5_MAC_GENERAL\"");
quote(ml, "| 805n -> \"cKM_CAST5_CBC_PAD\"");
quote(ml, "| 816n -> \"cKM_RC5_KEY_GEN\"");
quote(ml, "| 817n -> \"cKM_RC5_ECB\"");
quote(ml, "| 818n -> \"cKM_RC5_CBC\"");
quote(ml, "| 819n -> \"cKM_RC5_MAC\"");
quote(ml, "| 820n -> \"cKM_RC5_MAC_GENERAL\"");
quote(ml, "| 821n -> \"cKM_RC5_CBC_PAD\"");
quote(ml, "| 832n -> \"cKM_IDEA_KEY_GEN\"");
quote(ml, "| 833n -> \"cKM_IDEA_ECB\"");
quote(ml, "| 834n -> \"cKM_IDEA_CBC\"");
quote(ml, "| 835n -> \"cKM_IDEA_MAC\"");
quote(ml, "| 836n -> \"cKM_IDEA_MAC_GENERAL\"");
quote(ml, "| 837n -> \"cKM_IDEA_CBC_PAD\"");
quote(ml, "| 848n -> \"cKM_GENERIC_SECRET_KEY_GEN\"");
quote(ml, "| 864n -> \"cKM_CONCATENATE_BASE_AND_KEY\"");
quote(ml, "| 866n -> \"cKM_CONCATENATE_BASE_AND_DATA\"");
quote(ml, "| 867n -> \"cKM_CONCATENATE_DATA_AND_BASE\"");
quote(ml, "| 868n -> \"cKM_XOR_BASE_AND_DATA\"");
quote(ml, "| 869n -> \"cKM_EXTRACT_KEY_FROM_KEY\"");
quote(ml, "| 880n -> \"cKM_SSL3_PRE_MASTER_KEY_GEN\"");
quote(ml, "| 881n -> \"cKM_SSL3_MASTER_KEY_DERIVE\"");
quote(ml, "| 882n -> \"cKM_SSL3_KEY_AND_MAC_DERIVE\"");
quote(ml, "| 883n -> \"cKM_SSL3_MASTER_KEY_DERIVE_DH\"");
quote(ml, "| 884n -> \"cKM_TLS_PRE_MASTER_KEY_GEN\"");
quote(ml, "| 885n -> \"cKM_TLS_MASTER_KEY_DERIVE\"");
quote(ml, "| 886n -> \"cKM_TLS_KEY_AND_MAC_DERIVE\"");
quote(ml, "| 887n -> \"cKM_TLS_MASTER_KEY_DERIVE_DH\"");
quote(ml, "| 888n -> \"cKM_TLS_PRF\"");
quote(ml, "| 896n -> \"cKM_SSL3_MD5_MAC\"");
quote(ml, "| 897n -> \"cKM_SSL3_SHA1_MAC\"");
quote(ml, "| 912n -> \"cKM_MD5_KEY_DERIVATION\"");
quote(ml, "| 913n -> \"cKM_MD2_KEY_DERIVATION\"");
quote(ml, "| 914n -> \"cKM_SHA1_KEY_DERIVATION\"");
quote(ml, "| 915n -> \"cKM_SHA256_KEY_DERIVATION\"");
quote(ml, "| 916n -> \"cKM_SHA384_KEY_DERIVATION\"");
quote(ml, "| 917n -> \"cKM_SHA512_KEY_DERIVATION\"");
quote(ml, "| 918n -> \"cKM_SHA224_KEY_DERIVATION\"");
quote(ml, "| 928n -> \"cKM_PBE_MD2_DES_CBC\"");
quote(ml, "| 929n -> \"cKM_PBE_MD5_DES_CBC\"");
quote(ml, "| 930n -> \"cKM_PBE_MD5_CAST_CBC\"");
quote(ml, "| 931n -> \"cKM_PBE_MD5_CAST3_CBC\"");
quote(ml, "| 932n -> \"cKM_PBE_MD5_CAST5_CBC\"");
quote(ml, "| 933n -> \"cKM_PBE_SHA1_CAST5_CBC\"");
quote(ml, "| 934n -> \"cKM_PBE_SHA1_RC4_128\"");
quote(ml, "| 935n -> \"cKM_PBE_SHA1_RC4_40\"");
quote(ml, "| 936n -> \"cKM_PBE_SHA1_DES3_EDE_CBC\"");
quote(ml, "| 937n -> \"cKM_PBE_SHA1_DES2_EDE_CBC\"");
quote(ml, "| 938n -> \"cKM_PBE_SHA1_RC2_128_CBC\"");
quote(ml, "| 939n -> \"cKM_PBE_SHA1_RC2_40_CBC \"");
quote(ml, "| 944n -> \"cKM_PKCS5_PBKD2\"");
quote(ml, "| 960n -> \"cKM_PBA_SHA1_WITH_SHA1_HMAC\"");
quote(ml, "| 976n -> \"cKM_WTLS_PRE_MASTER_KEY_GEN\"");
quote(ml, "| 977n -> \"cKM_WTLS_MASTER_KEY_DERIVE\"");
quote(ml, "| 978n -> \"cKM_WTLS_MASTER_KEY_DERIVE_DH_ECC\"");
quote(ml, "| 979n -> \"cKM_WTLS_PRF\"");
quote(ml, "| 980n -> \"cKM_WTLS_SERVER_KEY_AND_MAC_DERIVE\"");
quote(ml, "| 981n -> \"cKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE\"");
quote(ml, "| 1024n -> \"cKM_KEY_WRAP_LYNKS\"");
quote(ml, "| 1025n -> \"cKM_KEY_WRAP_SET_OAEP\"");
quote(ml, "| 1280n -> \"cKM_CMS_SIG\"");
quote(ml, "| 1296n -> \"cKM_KIP_DERIVE\"");
quote(ml, "| 1297n -> \"cKM_KIP_WRAP\"");
quote(ml, "| 1298n -> \"cKM_KIP_MAC\"");
quote(ml, "| 1360n -> \"cKM_CAMELLIA_KEY_GEN\"");
quote(ml, "| 1361n -> \"cKM_CAMELLIA_ECB\"");
quote(ml, "| 1362n -> \"cKM_CAMELLIA_CBC\"");
quote(ml, "| 1363n -> \"cKM_CAMELLIA_MAC\"");
quote(ml, "| 1364n -> \"cKM_CAMELLIA_MAC_GENERAL\"");
quote(ml, "| 1365n -> \"cKM_CAMELLIA_CBC_PAD\"");
quote(ml, "| 1366n -> \"cKM_CAMELLIA_ECB_ENCRYPT_DATA\"");
quote(ml, "| 1367n -> \"cKM_CAMELLIA_CBC_ENCRYPT_DATA\"");
quote(ml, "| 1368n -> \"cKM_CAMELLIA_CTR\"");
quote(ml, "| 1376n -> \"cKM_ARIA_KEY_GEN\"");
quote(ml, "| 1377n -> \"cKM_ARIA_ECB\"");
quote(ml, "| 1378n -> \"cKM_ARIA_CBC\"");
quote(ml, "| 1379n -> \"cKM_ARIA_MAC\"");
quote(ml, "| 1380n -> \"cKM_ARIA_MAC_GENERAL\"");
quote(ml, "| 1381n -> \"cKM_ARIA_CBC_PAD\"");
quote(ml, "| 1382n -> \"cKM_ARIA_ECB_ENCRYPT_DATA\"");
quote(ml, "| 1383n -> \"cKM_ARIA_CBC_ENCRYPT_DATA\"");
quote(ml, "| 4096n -> \"cKM_SKIPJACK_KEY_GEN\"");
quote(ml, "| 4097n -> \"cKM_SKIPJACK_ECB64\"");
quote(ml, "| 4098n -> \"cKM_SKIPJACK_CBC64\"");
quote(ml, "| 4099n -> \"cKM_SKIPJACK_OFB64\"");
quote(ml, "| 4100n -> \"cKM_SKIPJACK_CFB64\"");
quote(ml, "| 4101n -> \"cKM_SKIPJACK_CFB32\"");
quote(ml, "| 4102n -> \"cKM_SKIPJACK_CFB16\"");
quote(ml, "| 4103n -> \"cKM_SKIPJACK_CFB8\"");
quote(ml, "| 4104n -> \"cKM_SKIPJACK_WRAP\"");
quote(ml, "| 4105n -> \"cKM_SKIPJACK_PRIVATE_WRAP\"");
quote(ml, "| 4106n -> \"cKM_SKIPJACK_RELAYX\"");
quote(ml, "| 4112n -> \"cKM_KEA_KEY_PAIR_GEN\"");
quote(ml, "| 4113n -> \"cKM_KEA_KEY_DERIVE\"");
quote(ml, "| 4128n -> \"cKM_FORTEZZA_TIMESTAMP\"");
quote(ml, "| 4144n -> \"cKM_BATON_KEY_GEN\"");
quote(ml, "| 4145n -> \"cKM_BATON_ECB128\"");
quote(ml, "| 4146n -> \"cKM_BATON_ECB96\"");
quote(ml, "| 4147n -> \"cKM_BATON_CBC128\"");
quote(ml, "| 4148n -> \"cKM_BATON_COUNTER\"");
quote(ml, "| 4149n -> \"cKM_BATON_SHUFFLE\"");
quote(ml, "| 4150n -> \"cKM_BATON_WRAP\"");
quote(ml, "| 4160n -> \"cKM_EC_KEY_PAIR_GEN\"");
quote(ml, "| 4161n -> \"cKM_ECDSA\"");
quote(ml, "| 4162n -> \"cKM_ECDSA_SHA1\"");
quote(ml, "| 4176n -> \"cKM_ECDH1_DERIVE\"");
quote(ml, "| 4177n -> \"cKM_ECDH1_COFACTOR_DERIVE\"");
quote(ml, "| 4178n -> \"cKM_ECMQV_DERIVE\"");
quote(ml, "| 4192n -> \"cKM_JUNIPER_KEY_GEN\"");
quote(ml, "| 4193n -> \"cKM_JUNIPER_ECB128\"");
quote(ml, "| 4194n -> \"cKM_JUNIPER_CBC128\"");
quote(ml, "| 4195n -> \"cKM_JUNIPER_COUNTER\"");
quote(ml, "| 4196n -> \"cKM_JUNIPER_SHUFFLE\"");
quote(ml, "| 4197n -> \"cKM_JUNIPER_WRAP\"");
quote(ml, "| 4208n -> \"cKM_FASTHASH\"");
quote(ml, "| 4224n -> \"cKM_AES_KEY_GEN\"");
quote(ml, "| 4225n -> \"cKM_AES_ECB\"");
quote(ml, "| 4226n -> \"cKM_AES_CBC\"");
quote(ml, "| 4227n -> \"cKM_AES_MAC\"");
quote(ml, "| 4228n -> \"cKM_AES_MAC_GENERAL\"");
quote(ml, "| 4229n -> \"cKM_AES_CBC_PAD\"");
quote(ml, "| 4230n -> \"cKM_AES_CTR\"");
quote(ml, "| 4240n -> \"cKM_BLOWFISH_KEY_GEN\"");
quote(ml, "| 4241n -> \"cKM_BLOWFISH_CBC\"");
quote(ml, "| 4242n -> \"cKM_TWOFISH_KEY_GEN\"");
quote(ml, "| 4243n -> \"cKM_TWOFISH_CBC\"");
quote(ml, "| 4352n -> \"cKM_DES_ECB_ENCRYPT_DATA\"");
quote(ml, "| 4353n -> \"cKM_DES_CBC_ENCRYPT_DATA\"");
quote(ml, "| 4354n -> \"cKM_DES3_ECB_ENCRYPT_DATA\"");
quote(ml, "| 4355n -> \"cKM_DES3_CBC_ENCRYPT_DATA\"");
quote(ml, "| 4356n -> \"cKM_AES_ECB_ENCRYPT_DATA\"");
quote(ml, "| 4357n -> \"cKM_AES_CBC_ENCRYPT_DATA\"");
quote(ml, "| 8192n -> \"cKM_DSA_PARAMETER_GEN\"");
quote(ml, "| 8193n -> \"cKM_DH_PKCS_PARAMETER_GEN\"");
quote(ml, "| 8194n -> \"cKM_X9_42_DH_PARAMETER_GEN\"");
#if __LP64__
quote(ml, "| 2147483648n -> \"cKM_VENDOR_DEFINED\"");
#else
quote(ml, "| -2147483648n -> \"cKM_VENDOR_DEFINED\"");
#endif
quote(ml, "| _ -> \"cKM_UNKNOWN!\"");

quote(ml, "exception Mechanism_unknown of string");
quote(mli, "exception Mechanism_unknown of string");
quote(ml, "(* Our mechanisms for getting a mechanism from a string *)");
quote(ml, "let string_to_cKM_value a = match a with");
quote(ml, "  \"CKM_RSA_PKCS_KEY_PAIR_GEN\" -> 0n");
quote(ml, "| \"CKM_RSA_PKCS\" -> 1n");
quote(ml, "| \"CKM_RSA_9796\" -> 2n");
quote(ml, "| \"CKM_RSA_X_509\" -> 3n");
quote(ml, "| \"CKM_MD2_RSA_PKCS\" -> 4n");
quote(ml, "| \"CKM_MD5_RSA_PKCS\" -> 5n");
quote(ml, "| \"CKM_SHA1_RSA_PKCS\" -> 6n");
quote(ml, "| \"CKM_RIPEMD128_RSA_PKCS\" -> 7n");
quote(ml, "| \"CKM_RIPEMD160_RSA_PKCS\" -> 8n");
quote(ml, "| \"CKM_RSA_PKCS_OAEP\" -> 9n");
quote(ml, "| \"CKM_RSA_X9_31_KEY_PAIR_GEN\" -> 10n");
quote(ml, "| \"CKM_RSA_X9_31\" -> 11n");
quote(ml, "| \"CKM_SHA1_RSA_X9_31\" -> 12n");
quote(ml, "| \"CKM_RSA_PKCS_PSS\" -> 13n");
quote(ml, "| \"CKM_SHA1_RSA_PKCS_PSS\" -> 14n");
quote(ml, "| \"CKM_DSA_KEY_PAIR_GEN\" -> 16n");
quote(ml, "| \"CKM_DSA\" -> 17n");
quote(ml, "| \"CKM_DSA_SHA1\" -> 18n");
quote(ml, "| \"CKM_DH_PKCS_KEY_PAIR_GEN\" -> 32n");
quote(ml, "| \"CKM_DH_PKCS_DERIVE\" -> 33n");
quote(ml, "| \"CKM_X9_42_DH_KEY_PAIR_GEN\" -> 48n");
quote(ml, "| \"CKM_X9_42_DH_DERIVE\" -> 49n");
quote(ml, "| \"CKM_X9_42_DH_HYBRID_DERIVE\" -> 50n");
quote(ml, "| \"CKM_X9_42_MQV_DERIVE\" -> 51n");
quote(ml, "| \"CKM_SHA256_RSA_PKCS\" -> 64n");
quote(ml, "| \"CKM_SHA384_RSA_PKCS\" -> 65n");
quote(ml, "| \"CKM_SHA512_RSA_PKCS\" -> 66n");
quote(ml, "| \"CKM_SHA256_RSA_PKCS_PSS\" -> 67n");
quote(ml, "| \"CKM_SHA384_RSA_PKCS_PSS\" -> 68n");
quote(ml, "| \"CKM_SHA512_RSA_PKCS_PSS\" -> 69n");
quote(ml, "| \"CKM_RC2_KEY_GEN\" -> 256n");
quote(ml, "| \"CKM_RC2_ECB\" -> 257n");
quote(ml, "| \"CKM_RC2_CBC\" -> 258n");
quote(ml, "| \"CKM_RC2_MAC\" -> 259n");
quote(ml, "| \"CKM_RC2_MAC_GENERAL\" -> 260n");
quote(ml, "| \"CKM_RC2_CBC_PAD\" -> 261n");
quote(ml, "| \"CKM_RC4_KEY_GEN\" -> 272n");
quote(ml, "| \"CKM_RC4\" -> 273n");
quote(ml, "| \"CKM_DES_KEY_GEN\" -> 288n");
quote(ml, "| \"CKM_DES_ECB\" -> 289n");
quote(ml, "| \"CKM_DES_CBC\" -> 290n");
quote(ml, "| \"CKM_DES_MAC\" -> 291n");
quote(ml, "| \"CKM_DES_MAC_GENERAL\" -> 292n");
quote(ml, "| \"CKM_DES_CBC_PAD\" -> 293n");
quote(ml, "| \"CKM_DES2_KEY_GEN\" -> 304n");
quote(ml, "| \"CKM_DES3_KEY_GEN\" -> 305n");
quote(ml, "| \"CKM_DES3_ECB\" -> 306n");
quote(ml, "| \"CKM_DES3_CBC\" -> 307n");
quote(ml, "| \"CKM_DES3_MAC\" -> 308n");
quote(ml, "| \"CKM_DES3_MAC_GENERAL\" -> 309n");
quote(ml, "| \"CKM_DES3_CBC_PAD\" -> 310n");
quote(ml, "| \"CKM_CDMF_KEY_GEN\" -> 320n");
quote(ml, "| \"CKM_CDMF_ECB\" -> 321n");
quote(ml, "| \"CKM_CDMF_CBC\" -> 322n");
quote(ml, "| \"CKM_CDMF_MAC\" -> 323n");
quote(ml, "| \"CKM_CDMF_MAC_GENERAL\" -> 324n");
quote(ml, "| \"CKM_CDMF_CBC_PAD\" -> 325n");
quote(ml, "| \"CKM_MD2\" -> 512n");
quote(ml, "| \"CKM_MD2_HMAC\" -> 513n");
quote(ml, "| \"CKM_MD2_HMAC_GENERAL\" -> 514n");
quote(ml, "| \"CKM_MD5\" -> 528n");
quote(ml, "| \"CKM_MD5_HMAC\" -> 529n");
quote(ml, "| \"CKM_MD5_HMAC_GENERAL\" -> 530n");
quote(ml, "| \"CKM_SHA_1\" -> 544n");
quote(ml, "| \"CKM_SHA_1_HMAC\" -> 545n");
quote(ml, "| \"CKM_SHA_1_HMAC_GENERAL\" -> 546n");
quote(ml, "| \"CKM_RIPEMD128\" -> 560n");
quote(ml, "| \"CKM_RIPEMD128_HMAC\" -> 561n");
quote(ml, "| \"CKM_RIPEMD128_HMAC_GENERAL\" -> 562n");
quote(ml, "| \"CKM_RIPEMD160\" -> 576n");
quote(ml, "| \"CKM_RIPEMD160_HMAC\" -> 577n");
quote(ml, "| \"CKM_RIPEMD160_HMAC_GENERAL\" -> 578n");
quote(ml, "| \"CKM_SHA256\" -> 592n");
quote(ml, "| \"CKM_SHA256_HMAC\" -> 593n");
quote(ml, "| \"CKM_SHA256_HMAC_GENERAL\" -> 594n");
quote(ml, "| \"CKM_SHA384\" -> 608n");
quote(ml, "| \"CKM_SHA384_HMAC\" -> 609n");
quote(ml, "| \"CKM_SHA384_HMAC_GENERAL\" -> 610n");
quote(ml, "| \"CKM_SHA512\" -> 624n");
quote(ml, "| \"CKM_SHA512_HMAC\" -> 625n");
quote(ml, "| \"CKM_SHA512_HMAC_GENERAL\" -> 626n");
quote(ml, "| \"CKM_CAST_KEY_GEN\" -> 768n");
quote(ml, "| \"CKM_CAST_ECB\" -> 769n");
quote(ml, "| \"CKM_CAST_CBC\" -> 770n");
quote(ml, "| \"CKM_CAST_MAC\" -> 771n");
quote(ml, "| \"CKM_CAST_MAC_GENERAL\" -> 772n");
quote(ml, "| \"CKM_CAST_CBC_PAD\" -> 773n");
quote(ml, "| \"CKM_CAST3_KEY_GEN\" -> 784n");
quote(ml, "| \"CKM_CAST3_ECB\" -> 785n");
quote(ml, "| \"CKM_CAST3_CBC\" -> 786n");
quote(ml, "| \"CKM_CAST3_MAC\" -> 787n");
quote(ml, "| \"CKM_CAST3_MAC_GENERAL\" -> 788n");
quote(ml, "| \"CKM_CAST3_CBC_PAD\" -> 789n");
quote(ml, "| \"CKM_CAST5_KEY_GEN\" -> 800n");
quote(ml, "| \"CKM_CAST5_ECB\" -> 801n");
quote(ml, "| \"CKM_CAST5_CBC\" -> 802n");
quote(ml, "| \"CKM_CAST5_MAC\" -> 803n");
quote(ml, "| \"CKM_CAST5_MAC_GENERAL\" -> 804n");
quote(ml, "| \"CKM_CAST5_CBC_PAD\" -> 805n");
quote(ml, "| \"CKM_RC5_KEY_GEN\" -> 816n");
quote(ml, "| \"CKM_RC5_ECB\" -> 817n");
quote(ml, "| \"CKM_RC5_CBC\" -> 818n");
quote(ml, "| \"CKM_RC5_MAC\" -> 819n");
quote(ml, "| \"CKM_RC5_MAC_GENERAL\" -> 820n");
quote(ml, "| \"CKM_RC5_CBC_PAD\" -> 821n");
quote(ml, "| \"CKM_IDEA_KEY_GEN\" -> 832n");
quote(ml, "| \"CKM_IDEA_ECB\" -> 833n");
quote(ml, "| \"CKM_IDEA_CBC\" -> 834n");
quote(ml, "| \"CKM_IDEA_MAC\" -> 835n");
quote(ml, "| \"CKM_IDEA_MAC_GENERAL\" -> 836n");
quote(ml, "| \"CKM_IDEA_CBC_PAD\" -> 837n");
quote(ml, "| \"CKM_GENERIC_SECRET_KEY_GEN\" -> 848n");
quote(ml, "| \"CKM_CONCATENATE_BASE_AND_KEY\" -> 864n");
quote(ml, "| \"CKM_CONCATENATE_BASE_AND_DATA\" -> 866n");
quote(ml, "| \"CKM_CONCATENATE_DATA_AND_BASE\" -> 867n");
quote(ml, "| \"CKM_XOR_BASE_AND_DATA\" -> 868n");
quote(ml, "| \"CKM_EXTRACT_KEY_FROM_KEY\" -> 869n");
quote(ml, "| \"CKM_SSL3_PRE_MASTER_KEY_GEN\" -> 880n");
quote(ml, "| \"CKM_SSL3_MASTER_KEY_DERIVE\" -> 881n");
quote(ml, "| \"CKM_SSL3_KEY_AND_MAC_DERIVE\" -> 882n");
quote(ml, "| \"CKM_SSL3_MASTER_KEY_DERIVE_DH\" -> 883n");
quote(ml, "| \"CKM_TLS_PRE_MASTER_KEY_GEN\" -> 884n");
quote(ml, "| \"CKM_TLS_MASTER_KEY_DERIVE\" -> 885n");
quote(ml, "| \"CKM_TLS_KEY_AND_MAC_DERIVE\" -> 886n");
quote(ml, "| \"CKM_TLS_MASTER_KEY_DERIVE_DH\" -> 887n");
quote(ml, "| \"CKM_SSL3_MD5_MAC\" -> 896n");
quote(ml, "| \"CKM_SSL3_SHA1_MAC\" -> 897n");
quote(ml, "| \"CKM_MD5_KEY_DERIVATION\" -> 912n");
quote(ml, "| \"CKM_MD2_KEY_DERIVATION\" -> 913n");
quote(ml, "| \"CKM_SHA1_KEY_DERIVATION\" -> 914n");
quote(ml, "| \"CKM_SHA256_KEY_DERIVATION\" -> 915n");
quote(ml, "| \"CKM_SHA384_KEY_DERIVATION\" -> 916n");
quote(ml, "| \"CKM_SHA512_KEY_DERIVATION\" -> 917n");
quote(ml, "| \"CKM_SHA224_KEY_DERIVATION\" -> 918n");
quote(ml, "| \"CKM_PBE_MD2_DES_CBC\" -> 928n");
quote(ml, "| \"CKM_PBE_MD5_DES_CBC\" -> 929n");
quote(ml, "| \"CKM_PBE_MD5_CAST_CBC\" -> 930n");
quote(ml, "| \"CKM_PBE_MD5_CAST3_CBC\" -> 931n");
quote(ml, "| \"CKM_PBE_MD5_CAST5_CBC\" -> 932n");
quote(ml, "| \"CKM_PBE_SHA1_CAST5_CBC\" -> 933n");
quote(ml, "| \"CKM_PBE_SHA1_RC4_128\" -> 934n");
quote(ml, "| \"CKM_PBE_SHA1_RC4_40\" -> 935n");
quote(ml, "| \"CKM_PBE_SHA1_DES3_EDE_CBC\" -> 936n");
quote(ml, "| \"CKM_PBE_SHA1_DES2_EDE_CBC\" -> 937n");
quote(ml, "| \"CKM_PBE_SHA1_RC2_128_CBC\" -> 938n");
quote(ml, "| \"CKM_PBE_SHA1_RC2_40_CBC\" -> 939n");
quote(ml, "| \"CKM_PKCS5_PBKD2\" -> 944n");
quote(ml, "| \"CKM_PBA_SHA1_WITH_SHA1_HMAC\" -> 960n");
quote(ml, "| \"CKM_WTLS_PRE_MASTER_KEY_GEN\" -> 976n");
quote(ml, "| \"CKM_WTLS_MASTER_KEY_DERIVE\" -> 977n");
quote(ml, "| \"CKM_WTLS_MASTER_KEY_DERIVE_DH_ECC\" -> 978n");
quote(ml, "| \"CKM_WTLS_PRF\" -> 979n");
quote(ml, "| \"CKM_WTLS_SERVER_KEY_AND_MAC_DERIVE\" -> 980n");
quote(ml, "| \"CKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE\" -> 981n");
quote(ml, "| \"CKM_KEY_WRAP_LYNKS\" -> 1024n");
quote(ml, "| \"CKM_KEY_WRAP_SET_OAEP\" -> 1025n");
quote(ml, "| \"CKM_CMS_SIG\" -> 1280n");
quote(ml, "| \"CKM_KIP_DERIVE\" -> 1296n");
quote(ml, "| \"CKM_KIP_WRAP\" -> 1297n");
quote(ml, "| \"CKM_KIP_MAC\" -> 1298n");
quote(ml, "| \"CKM_CAMELLIA_KEY_GEN\" -> 1360n");
quote(ml, "| \"CKM_CAMELLIA_ECB\" -> 1361n");
quote(ml, "| \"CKM_CAMELLIA_CBC\" -> 1362n");
quote(ml, "| \"CKM_CAMELLIA_MAC\" -> 1363n");
quote(ml, "| \"CKM_CAMELLIA_MAC_GENERAL\" -> 1364n");
quote(ml, "| \"CKM_CAMELLIA_CBC_PAD\" -> 1365n");
quote(ml, "| \"CKM_CAMELLIA_ECB_ENCRYPT_DATA\" -> 1366n");
quote(ml, "| \"CKM_CAMELLIA_CBC_ENCRYPT_DATA\" -> 1367n");
quote(ml, "| \"CKM_CAMELLIA_CTR\" -> 1368n");
quote(ml, "| \"CKM_ARIA_KEY_GEN\" -> 1376n");
quote(ml, "| \"CKM_ARIA_ECB\" -> 1377n");
quote(ml, "| \"CKM_ARIA_CBC\" -> 1378n");
quote(ml, "| \"CKM_ARIA_MAC\" -> 1379n");
quote(ml, "| \"CKM_ARIA_MAC_GENERAL\" -> 1380n");
quote(ml, "| \"CKM_ARIA_CBC_PAD\" -> 1381n");
quote(ml, "| \"CKM_ARIA_ECB_ENCRYPT_DATA\" -> 1382n");
quote(ml, "| \"CKM_ARIA_CBC_ENCRYPT_DATA\" -> 1383n");
quote(ml, "| \"CKM_SKIPJACK_KEY_GEN\" -> 4096n");
quote(ml, "| \"CKM_SKIPJACK_ECB64\" -> 4097n");
quote(ml, "| \"CKM_SKIPJACK_CBC64\" -> 4098n");
quote(ml, "| \"CKM_SKIPJACK_OFB64\" -> 4099n");
quote(ml, "| \"CKM_SKIPJACK_CFB64\" -> 4100n");
quote(ml, "| \"CKM_SKIPJACK_CFB32\" -> 4101n");
quote(ml, "| \"CKM_SKIPJACK_CFB16\" -> 4102n");
quote(ml, "| \"CKM_SKIPJACK_CFB8\" -> 4103n");
quote(ml, "| \"CKM_SKIPJACK_WRAP\" -> 4104n");
quote(ml, "| \"CKM_SKIPJACK_PRIVATE_WRAP\" -> 4105n");
quote(ml, "| \"CKM_SKIPJACK_RELAYX\" -> 4106n");
quote(ml, "| \"CKM_KEA_KEY_PAIR_GEN\" -> 4112n");
quote(ml, "| \"CKM_KEA_KEY_DERIVE\" -> 4113n");
quote(ml, "| \"CKM_FORTEZZA_TIMESTAMP\" -> 4128n");
quote(ml, "| \"CKM_BATON_KEY_GEN\" -> 4144n");
quote(ml, "| \"CKM_BATON_ECB128\" -> 4145n");
quote(ml, "| \"CKM_BATON_ECB96\" -> 4146n");
quote(ml, "| \"CKM_BATON_CBC128\" -> 4147n");
quote(ml, "| \"CKM_BATON_COUNTER\" -> 4148n");
quote(ml, "| \"CKM_BATON_SHUFFLE\" -> 4149n");
quote(ml, "| \"CKM_BATON_WRAP\" -> 4150n");
quote(ml, "| \"CKM_ECDSA_KEY_PAIR_GEN\" -> 4160n");
quote(ml, "| \"CKM_ECDSA\" -> 4161n");
quote(ml, "| \"CKM_ECDSA_SHA1\" -> 4162n");
quote(ml, "| \"CKM_ECDH1_DERIVE\" -> 4176n");
quote(ml, "| \"CKM_ECDH1_COFACTOR_DERIVE\" -> 4177n");
quote(ml, "| \"CKM_ECMQV_DERIVE\" -> 4178n");
quote(ml, "| \"CKM_JUNIPER_KEY_GEN\" -> 4192n");
quote(ml, "| \"CKM_JUNIPER_ECB128\" -> 4193n");
quote(ml, "| \"CKM_JUNIPER_CBC128\" -> 4194n");
quote(ml, "| \"CKM_JUNIPER_COUNTER\" -> 4195n");
quote(ml, "| \"CKM_JUNIPER_SHUFFLE\" -> 4196n");
quote(ml, "| \"CKM_JUNIPER_WRAP\" -> 4197n");
quote(ml, "| \"CKM_FASTHASH\" -> 4208n");
quote(ml, "| \"CKM_AES_KEY_GEN\" -> 4224n");
quote(ml, "| \"CKM_AES_ECB\" -> 4225n");
quote(ml, "| \"CKM_AES_CBC\" -> 4226n");
quote(ml, "| \"CKM_AES_MAC\" -> 4227n");
quote(ml, "| \"CKM_AES_MAC_GENERAL\" -> 4228n");
quote(ml, "| \"CKM_AES_CBC_PAD\" -> 4229n");
quote(ml, "| \"CKM_AES_CTR\" -> 4230n");
quote(ml, "| \"CKM_BLOWFISH_KEY_GEN\" -> 4240n");
quote(ml, "| \"CKM_BLOWFISH_CBC\" -> 4241n");
quote(ml, "| \"CKM_TWOFISH_KEY_GEN\" -> 4242n");
quote(ml, "| \"CKM_TWOFISH_CBC\" -> 4243n");
quote(ml, "| \"CKM_DES_ECB_ENCRYPT_DATA\" -> 4352n");
quote(ml, "| \"CKM_DES_CBC_ENCRYPT_DATA\" -> 4353n");
quote(ml, "| \"CKM_DES3_ECB_ENCRYPT_DATA\" -> 4354n");
quote(ml, "| \"CKM_DES3_CBC_ENCRYPT_DATA\" -> 4355n");
quote(ml, "| \"CKM_AES_ECB_ENCRYPT_DATA\" -> 4356n");
quote(ml, "| \"CKM_AES_CBC_ENCRYPT_DATA\" -> 4357n");
quote(ml, "| \"CKM_DSA_PARAMETER_GEN\" -> 8192n");
quote(ml, "| \"CKM_DH_PKCS_PARAMETER_GEN\" -> 8193n");
quote(ml, "| \"CKM_X9_42_DH_PARAMETER_GEN\" -> 8194n");
#if __LP64__
quote(ml, "| \"CKM_VENDOR_DEFINED\" -> 2147483648n");
#else
quote(ml, "| \"CKM_VENDOR_DEFINED\" -> -2147483648n");
#endif
quote(ml, "| \"cKM_RSA_PKCS_KEY_PAIR_GEN\" -> 0n");
quote(ml, "| \"cKM_RSA_PKCS\" -> 1n");
quote(ml, "| \"cKM_RSA_9796\" -> 2n");
quote(ml, "| \"cKM_RSA_X_509\" -> 3n");
quote(ml, "| \"cKM_MD2_RSA_PKCS\" -> 4n");
quote(ml, "| \"cKM_MD5_RSA_PKCS\" -> 5n");
quote(ml, "| \"cKM_SHA1_RSA_PKCS\" -> 6n");
quote(ml, "| \"cKM_RIPEMD128_RSA_PKCS\" -> 7n");
quote(ml, "| \"cKM_RIPEMD160_RSA_PKCS\" -> 8n");
quote(ml, "| \"cKM_RSA_PKCS_OAEP\" -> 9n");
quote(ml, "| \"cKM_RSA_X9_31_KEY_PAIR_GEN\" -> 10n");
quote(ml, "| \"cKM_RSA_X9_31\" -> 11n");
quote(ml, "| \"cKM_SHA1_RSA_X9_31\" -> 12n");
quote(ml, "| \"cKM_RSA_PKCS_PSS\" -> 13n");
quote(ml, "| \"cKM_SHA1_RSA_PKCS_PSS\" -> 14n");
quote(ml, "| \"cKM_DSA_KEY_PAIR_GEN\" -> 16n");
quote(ml, "| \"cKM_DSA\" -> 17n");
quote(ml, "| \"cKM_DSA_SHA1\" -> 18n");
quote(ml, "| \"cKM_DH_PKCS_KEY_PAIR_GEN\" -> 32n");
quote(ml, "| \"cKM_DH_PKCS_DERIVE\" -> 33n");
quote(ml, "| \"cKM_X9_42_DH_KEY_PAIR_GEN\" -> 48n");
quote(ml, "| \"cKM_X9_42_DH_DERIVE\" -> 49n");
quote(ml, "| \"cKM_X9_42_DH_HYBRID_DERIVE\" -> 50n");
quote(ml, "| \"cKM_X9_42_MQV_DERIVE\" -> 51n");
quote(ml, "| \"cKM_SHA256_RSA_PKCS\" -> 64n");
quote(ml, "| \"cKM_SHA384_RSA_PKCS\" -> 65n");
quote(ml, "| \"cKM_SHA512_RSA_PKCS\" -> 66n");
quote(ml, "| \"cKM_SHA256_RSA_PKCS_PSS\" -> 67n");
quote(ml, "| \"cKM_SHA384_RSA_PKCS_PSS\" -> 68n");
quote(ml, "| \"cKM_SHA512_RSA_PKCS_PSS\" -> 69n");
quote(ml, "| \"cKM_SHA224_RSA_PKCS\" -> 70n");
quote(ml, "| \"cKM_SHA224_RSA_PKCS_PSS\" -> 71n");
quote(ml, "| \"cKM_RC2_KEY_GEN\" -> 256n");
quote(ml, "| \"cKM_RC2_ECB\" -> 257n");
quote(ml, "| \"cKM_RC2_CBC\" -> 258n");
quote(ml, "| \"cKM_RC2_MAC\" -> 259n");
quote(ml, "| \"cKM_RC2_MAC_GENERAL\" -> 260n");
quote(ml, "| \"cKM_RC2_CBC_PAD\" -> 261n");
quote(ml, "| \"cKM_RC4_KEY_GEN\" -> 272n");
quote(ml, "| \"cKM_RC4\" -> 273n");
quote(ml, "| \"cKM_DES_KEY_GEN\" -> 288n");
quote(ml, "| \"cKM_DES_ECB\" -> 289n");
quote(ml, "| \"cKM_DES_CBC\" -> 290n");
quote(ml, "| \"cKM_DES_MAC\" -> 291n");
quote(ml, "| \"cKM_DES_MAC_GENERAL\" -> 292n");
quote(ml, "| \"cKM_DES_CBC_PAD\" -> 293n");
quote(ml, "| \"cKM_DES2_KEY_GEN\" -> 304n");
quote(ml, "| \"cKM_DES3_KEY_GEN\" -> 305n");
quote(ml, "| \"cKM_DES3_ECB\" -> 306n");
quote(ml, "| \"cKM_DES3_CBC\" -> 307n");
quote(ml, "| \"cKM_DES3_MAC\" -> 308n");
quote(ml, "| \"cKM_DES3_MAC_GENERAL\" -> 309n");
quote(ml, "| \"cKM_DES3_CBC_PAD\" -> 310n");
quote(ml, "| \"cKM_CDMF_KEY_GEN\" -> 320n");
quote(ml, "| \"cKM_CDMF_ECB\" -> 321n");
quote(ml, "| \"cKM_CDMF_CBC\" -> 322n");
quote(ml, "| \"cKM_CDMF_MAC\" -> 323n");
quote(ml, "| \"cKM_CDMF_MAC_GENERAL\" -> 324n");
quote(ml, "| \"cKM_CDMF_CBC_PAD\" -> 325n");
quote(ml, "| \"cKM_MD2\" -> 512n");
quote(ml, "| \"cKM_MD2_HMAC\" -> 513n");
quote(ml, "| \"cKM_MD2_HMAC_GENERAL\" -> 514n");
quote(ml, "| \"cKM_MD5\" -> 528n");
quote(ml, "| \"cKM_MD5_HMAC\" -> 529n");
quote(ml, "| \"cKM_MD5_HMAC_GENERAL\" -> 530n");
quote(ml, "| \"cKM_SHA_1\" -> 544n");
quote(ml, "| \"cKM_SHA_1_HMAC\" -> 545n");
quote(ml, "| \"cKM_SHA_1_HMAC_GENERAL\" -> 546n");
quote(ml, "| \"cKM_RIPEMD128\" -> 560n");
quote(ml, "| \"cKM_RIPEMD128_HMAC\" -> 561n");
quote(ml, "| \"cKM_RIPEMD128_HMAC_GENERAL\" -> 562n");
quote(ml, "| \"cKM_RIPEMD160\" -> 576n");
quote(ml, "| \"cKM_RIPEMD160_HMAC\" -> 577n");
quote(ml, "| \"cKM_RIPEMD160_HMAC_GENERAL\" -> 578n");
quote(ml, "| \"cKM_SHA256\" -> 592n");
quote(ml, "| \"cKM_SHA256_HMAC\" -> 593n");
quote(ml, "| \"cKM_SHA256_HMAC_GENERAL\" -> 594n");
quote(ml, "| \"cKM_SHA384\" -> 608n");
quote(ml, "| \"cKM_SHA384_HMAC\" -> 609n");
quote(ml, "| \"cKM_SHA384_HMAC_GENERAL\" -> 610n");
quote(ml, "| \"cKM_SHA512\" -> 624n");
quote(ml, "| \"cKM_SHA512_HMAC\" -> 625n");
quote(ml, "| \"cKM_SHA512_HMAC_GENERAL\" -> 626n");
quote(ml, "| \"cKM_CAST_KEY_GEN\" -> 768n");
quote(ml, "| \"cKM_CAST_ECB\" -> 769n");
quote(ml, "| \"cKM_CAST_CBC\" -> 770n");
quote(ml, "| \"cKM_CAST_MAC\" -> 771n");
quote(ml, "| \"cKM_CAST_MAC_GENERAL\" -> 772n");
quote(ml, "| \"cKM_CAST_CBC_PAD\" -> 773n");
quote(ml, "| \"cKM_CAST3_KEY_GEN\" -> 784n");
quote(ml, "| \"cKM_CAST3_ECB\" -> 785n");
quote(ml, "| \"cKM_CAST3_CBC\" -> 786n");
quote(ml, "| \"cKM_CAST3_MAC\" -> 787n");
quote(ml, "| \"cKM_CAST3_MAC_GENERAL\" -> 788n");
quote(ml, "| \"cKM_CAST3_CBC_PAD\" -> 789n");
quote(ml, "| \"cKM_CAST5_KEY_GEN\" -> 800n");
quote(ml, "| \"cKM_CAST5_ECB\" -> 801n");
quote(ml, "| \"cKM_CAST5_CBC\" -> 802n");
quote(ml, "| \"cKM_CAST5_MAC\" -> 803n");
quote(ml, "| \"cKM_CAST5_MAC_GENERAL\" -> 804n");
quote(ml, "| \"cKM_CAST5_CBC_PAD\" -> 805n");
quote(ml, "| \"cKM_RC5_KEY_GEN\" -> 816n");
quote(ml, "| \"cKM_RC5_ECB\" -> 817n");
quote(ml, "| \"cKM_RC5_CBC\" -> 818n");
quote(ml, "| \"cKM_RC5_MAC\" -> 819n");
quote(ml, "| \"cKM_RC5_MAC_GENERAL\" -> 820n");
quote(ml, "| \"cKM_RC5_CBC_PAD\" -> 821n");
quote(ml, "| \"cKM_IDEA_KEY_GEN\" -> 832n");
quote(ml, "| \"cKM_IDEA_ECB\" -> 833n");
quote(ml, "| \"cKM_IDEA_CBC\" -> 834n");
quote(ml, "| \"cKM_IDEA_MAC\" -> 835n");
quote(ml, "| \"cKM_IDEA_MAC_GENERAL\" -> 836n");
quote(ml, "| \"cKM_IDEA_CBC_PAD\" -> 837n");
quote(ml, "| \"cKM_GENERIC_SECRET_KEY_GEN\" -> 848n");
quote(ml, "| \"cKM_CONCATENATE_BASE_AND_KEY\" -> 864n");
quote(ml, "| \"cKM_CONCATENATE_BASE_AND_DATA\" -> 866n");
quote(ml, "| \"cKM_CONCATENATE_DATA_AND_BASE\" -> 867n");
quote(ml, "| \"cKM_XOR_BASE_AND_DATA\" -> 868n");
quote(ml, "| \"cKM_EXTRACT_KEY_FROM_KEY\" -> 869n");
quote(ml, "| \"cKM_SSL3_PRE_MASTER_KEY_GEN\" -> 880n");
quote(ml, "| \"cKM_SSL3_MASTER_KEY_DERIVE\" -> 881n");
quote(ml, "| \"cKM_SSL3_KEY_AND_MAC_DERIVE\" -> 882n");
quote(ml, "| \"cKM_SSL3_MASTER_KEY_DERIVE_DH\" -> 883n");
quote(ml, "| \"cKM_TLS_PRE_MASTER_KEY_GEN\" -> 884n");
quote(ml, "| \"cKM_TLS_MASTER_KEY_DERIVE\" -> 885n");
quote(ml, "| \"cKM_TLS_KEY_AND_MAC_DERIVE\" -> 886n");
quote(ml, "| \"cKM_TLS_MASTER_KEY_DERIVE_DH\" -> 887n");
quote(ml, "| \"cKM_TLS_PRF\" -> 888n");
quote(ml, "| \"cKM_SSL3_MD5_MAC\" -> 896n");
quote(ml, "| \"cKM_SSL3_SHA1_MAC\" -> 897n");
quote(ml, "| \"cKM_MD5_KEY_DERIVATION\" -> 912n");
quote(ml, "| \"cKM_MD2_KEY_DERIVATION\" -> 913n");
quote(ml, "| \"cKM_SHA1_KEY_DERIVATION\" -> 914n");
quote(ml, "| \"cKM_SHA256_KEY_DERIVATION\" -> 915n");
quote(ml, "| \"cKM_SHA384_KEY_DERIVATION\" -> 916n");
quote(ml, "| \"cKM_SHA512_KEY_DERIVATION\" -> 917n");
quote(ml, "| \"cKM_SHA224_KEY_DERIVATION\" -> 918n");
quote(ml, "| \"cKM_PBE_MD2_DES_CBC\" -> 928n");
quote(ml, "| \"cKM_PBE_MD5_DES_CBC\" -> 929n");
quote(ml, "| \"cKM_PBE_MD5_CAST_CBC\" -> 930n");
quote(ml, "| \"cKM_PBE_MD5_CAST3_CBC\" -> 931n");
quote(ml, "| \"cKM_PBE_MD5_CAST5_CBC\" -> 932n");
quote(ml, "| \"cKM_PBE_SHA1_CAST5_CBC\" -> 933n");
quote(ml, "| \"cKM_PBE_SHA1_RC4_128\" -> 934n");
quote(ml, "| \"cKM_PBE_SHA1_RC4_40\" -> 935n");
quote(ml, "| \"cKM_PBE_SHA1_DES3_EDE_CBC\" -> 936n");
quote(ml, "| \"cKM_PBE_SHA1_DES2_EDE_CBC\" -> 937n");
quote(ml, "| \"cKM_PBE_SHA1_RC2_128_CBC\" -> 938n");
quote(ml, "| \"cKM_PBE_SHA1_RC2_40_CBC\" -> 939n");
quote(ml, "| \"cKM_PKCS5_PBKD2\" -> 944n");
quote(ml, "| \"cKM_PBA_SHA1_WITH_SHA1_HMAC\" -> 960n");
quote(ml, "| \"cKM_WTLS_PRE_MASTER_KEY_GEN\" -> 976n");
quote(ml, "| \"cKM_WTLS_MASTER_KEY_DERIVE\" -> 977n");
quote(ml, "| \"cKM_WTLS_MASTER_KEY_DERIVE_DH_ECC\" -> 978n");
quote(ml, "| \"cKM_WTLS_PRF\" -> 979n");
quote(ml, "| \"cKM_WTLS_SERVER_KEY_AND_MAC_DERIVE\" -> 980n");
quote(ml, "| \"cKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE\" -> 981n");
quote(ml, "| \"cKM_KEY_WRAP_LYNKS\" -> 1024n");
quote(ml, "| \"cKM_KEY_WRAP_SET_OAEP\" -> 1025n");
quote(ml, "| \"cKM_CMS_SIG\" -> 1280n");
quote(ml, "| \"cKM_KIP_DERIVE\" -> 1296n");
quote(ml, "| \"cKM_KIP_WRAP\" -> 1297n");
quote(ml, "| \"cKM_KIP_MAC\" -> 1298n");
quote(ml, "| \"cKM_CAMELLIA_KEY_GEN\" -> 1360n");
quote(ml, "| \"cKM_CAMELLIA_ECB\" -> 1361n");
quote(ml, "| \"cKM_CAMELLIA_CBC\" -> 1362n");
quote(ml, "| \"cKM_CAMELLIA_MAC\" -> 1363n");
quote(ml, "| \"cKM_CAMELLIA_MAC_GENERAL\" -> 1364n");
quote(ml, "| \"cKM_CAMELLIA_CBC_PAD\" -> 1365n");
quote(ml, "| \"cKM_CAMELLIA_ECB_ENCRYPT_DATA\" -> 1366n");
quote(ml, "| \"cKM_CAMELLIA_CBC_ENCRYPT_DATA\" -> 1367n");
quote(ml, "| \"cKM_CAMELLIA_CTR\" -> 1368n");
quote(ml, "| \"cKM_ARIA_KEY_GEN\" -> 1376n");
quote(ml, "| \"cKM_ARIA_ECB\" -> 1377n");
quote(ml, "| \"cKM_ARIA_CBC\" -> 1378n");
quote(ml, "| \"cKM_ARIA_MAC\" -> 1379n");
quote(ml, "| \"cKM_ARIA_MAC_GENERAL\" -> 1380n");
quote(ml, "| \"cKM_ARIA_CBC_PAD\" -> 1381n");
quote(ml, "| \"cKM_ARIA_ECB_ENCRYPT_DATA\" -> 1382n");
quote(ml, "| \"cKM_ARIA_CBC_ENCRYPT_DATA\" -> 1383n");
quote(ml, "| \"cKM_SKIPJACK_KEY_GEN\" -> 4096n");
quote(ml, "| \"cKM_SKIPJACK_ECB64\" -> 4097n");
quote(ml, "| \"cKM_SKIPJACK_CBC64\" -> 4098n");
quote(ml, "| \"cKM_SKIPJACK_OFB64\" -> 4099n");
quote(ml, "| \"cKM_SKIPJACK_CFB64\" -> 4100n");
quote(ml, "| \"cKM_SKIPJACK_CFB32\" -> 4101n");
quote(ml, "| \"cKM_SKIPJACK_CFB16\" -> 4102n");
quote(ml, "| \"cKM_SKIPJACK_CFB8\" -> 4103n");
quote(ml, "| \"cKM_SKIPJACK_WRAP\" -> 4104n");
quote(ml, "| \"cKM_SKIPJACK_PRIVATE_WRAP\" -> 4105n");
quote(ml, "| \"cKM_SKIPJACK_RELAYX\" -> 4106n");
quote(ml, "| \"cKM_KEA_KEY_PAIR_GEN\" -> 4112n");
quote(ml, "| \"cKM_KEA_KEY_DERIVE\" -> 4113n");
quote(ml, "| \"cKM_FORTEZZA_TIMESTAMP\" -> 4128n");
quote(ml, "| \"cKM_BATON_KEY_GEN\" -> 4144n");
quote(ml, "| \"cKM_BATON_ECB128\" -> 4145n");
quote(ml, "| \"cKM_BATON_ECB96\" -> 4146n");
quote(ml, "| \"cKM_BATON_CBC128\" -> 4147n");
quote(ml, "| \"cKM_BATON_COUNTER\" -> 4148n");
quote(ml, "| \"cKM_BATON_SHUFFLE\" -> 4149n");
quote(ml, "| \"cKM_BATON_WRAP\" -> 4150n");
quote(ml, "| \"cKM_EC_KEY_PAIR_GEN\" -> 4160n");
quote(ml, "| \"cKM_ECDSA\" -> 4161n");
quote(ml, "| \"cKM_ECDSA_SHA1\" -> 4162n");
quote(ml, "| \"cKM_ECDH1_DERIVE\" -> 4176n");
quote(ml, "| \"cKM_ECDH1_COFACTOR_DERIVE\" -> 4177n");
quote(ml, "| \"cKM_ECMQV_DERIVE\" -> 4178n");
quote(ml, "| \"cKM_JUNIPER_KEY_GEN\" -> 4192n");
quote(ml, "| \"cKM_JUNIPER_ECB128\" -> 4193n");
quote(ml, "| \"cKM_JUNIPER_CBC128\" -> 4194n");
quote(ml, "| \"cKM_JUNIPER_COUNTER\" -> 4195n");
quote(ml, "| \"cKM_JUNIPER_SHUFFLE\" -> 4196n");
quote(ml, "| \"cKM_JUNIPER_WRAP\" -> 4197n");
quote(ml, "| \"cKM_FASTHASH\" -> 4208n");
quote(ml, "| \"cKM_AES_KEY_GEN\" -> 4224n");
quote(ml, "| \"cKM_AES_ECB\" -> 4225n");
quote(ml, "| \"cKM_AES_CBC\" -> 4226n");
quote(ml, "| \"cKM_AES_MAC\" -> 4227n");
quote(ml, "| \"cKM_AES_MAC_GENERAL\" -> 4228n");
quote(ml, "| \"cKM_AES_CBC_PAD\" -> 4229n");
quote(ml, "| \"cKM_AES_CTR\" -> 4230n");
quote(ml, "| \"cKM_BLOWFISH_KEY_GEN\" -> 4240n");
quote(ml, "| \"cKM_BLOWFISH_CBC\" -> 4241n");
quote(ml, "| \"cKM_TWOFISH_KEY_GEN\" -> 4242n");
quote(ml, "| \"cKM_TWOFISH_CBC\" -> 4243n");
quote(ml, "| \"cKM_DES_ECB_ENCRYPT_DATA\" -> 4352n");
quote(ml, "| \"cKM_DES_CBC_ENCRYPT_DATA\" -> 4353n");
quote(ml, "| \"cKM_DES3_ECB_ENCRYPT_DATA\" -> 4354n");
quote(ml, "| \"cKM_DES3_CBC_ENCRYPT_DATA\" -> 4355n");
quote(ml, "| \"cKM_AES_ECB_ENCRYPT_DATA\" -> 4356n");
quote(ml, "| \"cKM_AES_CBC_ENCRYPT_DATA\" -> 4357n");
quote(ml, "| \"cKM_DSA_PARAMETER_GEN\" -> 8192n");
quote(ml, "| \"cKM_DH_PKCS_PARAMETER_GEN\" -> 8193n");
quote(ml, "| \"cKM_X9_42_DH_PARAMETER_GEN\" -> 8194n");
#if __LP64__
quote(ml, "| \"cKM_VENDOR_DEFINED\" -> 2147483648n");
#else
quote(ml, "| \"cKM_VENDOR_DEFINED\" -> -2147483648n");
#endif
quote(ml, "| _ -> raise (Mechanism_unknown a)");

quote(ml, "let match_cKF_value a = match a with");
quote(ml,
      "| 1n -> \"cKF_TOKEN_PRESENT | ncKF_RNG | ncKF_HW | ncKF_DONT_BLOCK | ncKF_LIBRARY_CANT_CREATE_OS_THREADS\"");
quote(ml,
      "| 2n -> \"cKF_REMOVABLE_DEVICE | ncKF_RW_SESSION | ncKF_WRITE_PROTECTED | ncKF_OS_LOCKING_OK\"");
quote(ml,
      "| 4n -> \"cKF_HW_SLOT | ncKF_LOGIN_REQUIRED | ncKF_SERIAL_SESSION\"");
quote(ml, "| 1073741824n -> \"cKF_ARRAY_ATTRIBUTE\"");
quote(ml, "| 8n -> \"cKF_USER_PIN_INITIALIZED\"");
quote(ml, "| 32n -> \"cKF_RESTORE_KEY_NOT_NEEDED\"");
quote(ml, "| 64n -> \"cKF_CLOCK_ON_TOKEN\"");
quote(ml, "| 256n -> \"cKF_PROTECTED_AUTHENTICATION_PATH | ncKF_ENCRYPT\"");
quote(ml, "| 512n -> \"cKF_DUAL_CRYPTO_OPERATIONS | ncKF_DECRYPT\"");
quote(ml, "| 1024n -> \"cKF_TOKEN_INITIALIZED | ncKF_DIGEST\"");
quote(ml, "| 2048n -> \"cKF_SECONDARY_AUTHENTICATION | ncKF_SIGN\"");
quote(ml, "| 65536n -> \"cKF_USER_PIN_COUNT_LOW | ncKF_GENERATE_KEY_PAIR\"");
quote(ml, "| 131072n -> \"cKF_USER_PIN_FINAL_TRY | ncKF_WRAP\"");
quote(ml, "| 262144n -> \"cKF_USER_PIN_LOCKED | ncKF_UNWRAP\"");
quote(ml, "| 524288n -> \"cKF_USER_PIN_TO_BE_CHANGED | ncKF_DERIVE\"");
quote(ml, "| 1048576n -> \"cKF_SO_PIN_COUNT_LOW\"");
quote(ml, "| 2097152n -> \"cKF_SO_PIN_FINAL_TRY\"");
quote(ml, "| 4194304n -> \"cKF_SO_PIN_LOCKED\"");
quote(ml, "| 8388608n -> \"cKF_SO_PIN_TO_BE_CHANGED\"");
quote(ml, "| 4096n -> \"cKF_SIGN_RECOVER\"");
quote(ml, "| 8192n -> \"cKF_VERIFY\"");
quote(ml, "| 16384n -> \"cKF_VERIFY_RECOVER\"");
quote(ml, "| 32768n -> \"cKF_GENERATE\"");
#if __LP64__
quote(ml, "| 2147483648n -> \"cKF_EXTENSION\"");
#else
quote(ml, "| -2147483648n -> \"cKF_EXTENSION\"");
#endif
quote(ml, "| _ -> \"cKF_UNKNOWN!\"");

quote(ml, "let match_cKO_value a = match a with");
quote(ml, "| 0n -> \"cKO_DATA\"");
quote(ml, "| 1n -> \"cKO_CERTIFICATE\"");
quote(ml, "| 2n -> \"cKO_PUBLIC_KEY\"");
quote(ml, "| 3n -> \"cKO_PRIVATE_KEY\"");
quote(ml, "| 4n -> \"cKO_SECRET_KEY\"");
quote(ml, "| 5n -> \"cKO_HW_FEATURE\"");
quote(ml, "| 6n -> \"cKO_DOMAIN_PARAMETERS\"");
quote(ml, "| 7n -> \"cKO_MECHANISM\"");
#if __LP64__
quote(ml, "| 2147483648n -> \"cKO_VENDOR_DEFINED\"");
#else
quote(ml, "| -2147483648n -> \"cKO_VENDOR_DEFINED\"");
#endif
quote(ml, "| _ -> \"cKO_UNKNOWN!\"");

quote(ml, "let match_cKU_value a = match a with");
quote(ml, "| 0n -> \"cKU_SO\"");
quote(ml, "| 1n -> \"cKU_USER\"");
quote(ml, "| 2n -> \"cKU_CONTEXT_SPECIFIC\"");
quote(ml, "| _ -> \"cKU_UNKNOWN!\"");

quote(ml, "let match_cKA_value a = match a with");
quote(ml, "| 0n -> \"cKA_CLASS\"");
quote(ml, "| 1n -> \"cKA_TOKEN\"");
quote(ml, "| 2n -> \"cKA_PRIVATE\"");
quote(ml, "| 3n -> \"cKA_LABEL\"");
quote(ml, "| 16n -> \"cKA_APPLICATION\"");
quote(ml, "| 17n -> \"cKA_VALUE\"");
quote(ml, "| 18n -> \"cKA_OBJECT_ID\"");
quote(ml, "| 128n -> \"cKA_CERTIFICATE_TYPE\"");
quote(ml, "| 129n -> \"cKA_ISSUER\"");
quote(ml, "| 130n -> \"cKA_SERIAL_NUMBER\"");
quote(ml, "| 131n -> \"cKA_AC_ISSUER\"");
quote(ml, "| 132n -> \"cKA_OWNER\"");
quote(ml, "| 133n -> \"cKA_ATTR_TYPES\"");
quote(ml, "| 134n -> \"cKA_TRUSTED\"");
quote(ml, "| 135n -> \"cKA_CERTIFICATE_CATEGORY\"");
quote(ml, "| 136n -> \"cKA_JAVA_MIDP_SECURITY_DOMAIN\"");
quote(ml, "| 137n -> \"cKA_URL\"");
quote(ml, "| 138n -> \"cKA_HASH_OF_SUBJECT_PUBLIC_KEY\"");
quote(ml, "| 139n -> \"cKA_HASH_OF_ISSUER_PUBLIC_KEY\"");
quote(ml, "| 144n -> \"cKA_CHECK_VALUE\"");
quote(ml, "| 256n -> \"cKA_KEY_TYPE\"");
quote(ml, "| 257n -> \"cKA_SUBJECT\"");
quote(ml, "| 258n -> \"cKA_ID\"");
quote(ml, "| 259n -> \"cKA_SENSITIVE\"");
quote(ml, "| 260n -> \"cKA_ENCRYPT\"");
quote(ml, "| 261n -> \"cKA_DECRYPT\"");
quote(ml, "| 262n -> \"cKA_WRAP\"");
quote(ml, "| 263n -> \"cKA_UNWRAP\"");
quote(ml, "| 264n -> \"cKA_SIGN\"");
quote(ml, "| 265n -> \"cKA_SIGN_RECOVER\"");
quote(ml, "| 266n -> \"cKA_VERIFY\"");
quote(ml, "| 267n -> \"cKA_VERIFY_RECOVER\"");
quote(ml, "| 268n -> \"cKA_DERIVE\"");
quote(ml, "| 272n -> \"cKA_START_DATE\"");
quote(ml, "| 273n -> \"cKA_END_DATE\"");
quote(ml, "| 288n -> \"cKA_MODULUS\"");
quote(ml, "| 289n -> \"cKA_MODULUS_BITS\"");
quote(ml, "| 290n -> \"cKA_PUBLIC_EXPONENT\"");
quote(ml, "| 291n -> \"cKA_PRIVATE_EXPONENT\"");
quote(ml, "| 292n -> \"cKA_PRIME_1\"");
quote(ml, "| 293n -> \"cKA_PRIME_2\"");
quote(ml, "| 294n -> \"cKA_EXPONENT_1\"");
quote(ml, "| 295n -> \"cKA_EXPONENT_2\"");
quote(ml, "| 296n -> \"cKA_COEFFICIENT\"");
quote(ml, "| 304n -> \"cKA_PRIME\"");
quote(ml, "| 305n -> \"cKA_SUBPRIME\"");
quote(ml, "| 306n -> \"cKA_BASE\"");
quote(ml, "| 307n -> \"cKA_PRIME_BITS\"");
quote(ml, "| 308n -> \"cKA_SUB_PRIME_BITS\"");
quote(ml, "| 352n -> \"cKA_VALUE_BITS\"");
quote(ml, "| 353n -> \"cKA_VALUE_LEN\"");
quote(ml, "| 354n -> \"cKA_EXTRACTABLE\"");
quote(ml, "| 355n -> \"cKA_LOCAL\"");
quote(ml, "| 356n -> \"cKA_NEVER_EXTRACTABLE\"");
quote(ml, "| 357n -> \"cKA_ALWAYS_SENSITIVE\"");
quote(ml, "| 358n -> \"cKA_KEY_GEN_MECHANISM\"");
quote(ml, "| 368n -> \"cKA_MODIFIABLE\"");
quote(ml, "| 384n -> \"cKA_EC_PARAMS\"");
quote(ml, "| 385n -> \"cKA_EC_POINT\"");
quote(ml, "| 512n -> \"cKA_SECONDARY_AUTH\"");
quote(ml, "| 513n -> \"cKA_AUTH_PIN_FLAGS\"");
quote(ml, "| 514n -> \"cKA_ALWAYS_AUTHENTICATE\"");
quote(ml, "| 528n -> \"cKA_WRAP_WITH_TRUSTED\"");
quote(ml, "| 544n -> \"cKA_OTP_FORMAT\"");
quote(ml, "| 545n -> \"cKA_OTP_LENGTH\"");
quote(ml, "| 546n -> \"cKA_OTP_TIME_INTERVAL\"");
quote(ml, "| 547n -> \"cKA_OTP_USER_FRIENDLY_MODE\"");
quote(ml, "| 548n -> \"cKA_OTP_CHALLENGE_REQUIREMENT\"");
quote(ml, "| 549n -> \"cKA_OTP_TIME_REQUIREMENT\"");
quote(ml, "| 550n -> \"cKA_OTP_COUNTER_REQUIREMENT\"");
quote(ml, "| 551n -> \"cKA_OTP_PIN_REQUIREMENT\"");
quote(ml, "| 552n -> \"cKA_OTP_COUNTER\"");
quote(ml, "| 553n -> \"cKA_OTP_TIME\"");
quote(ml, "| 554n -> \"cKA_OTP_USER_IDENTIFIER\"");
quote(ml, "| 555n -> \"cKA_OTP_SERVICE_IDENTIFIER\"");
quote(ml, "| 556n -> \"cKA_OTP_SERVICE_LOGO\"");
quote(ml, "| 557n -> \"cKA_OTP_SERVICE_LOGO_TYPE\"");
quote(ml, "| 768n -> \"cKA_HW_FEATURE_TYPE\"");
quote(ml, "| 769n -> \"cKA_RESET_ON_INIT\"");
quote(ml, "| 770n -> \"cKA_HAS_RESET\"");
quote(ml, "| 1024n -> \"cKA_PIXEL_X\"");
quote(ml, "| 1025n -> \"cKA_PIXEL_Y\"");
quote(ml, "| 1026n -> \"cKA_RESOLUTION\"");
quote(ml, "| 1027n -> \"cKA_CHAR_ROWS\"");
quote(ml, "| 1028n -> \"cKA_CHAR_COLUMNS\"");
quote(ml, "| 1029n -> \"cKA_COLOR\"");
quote(ml, "| 1030n -> \"cKA_BITS_PER_PIXEL\"");
quote(ml, "| 1152n -> \"cKA_CHAR_SETS\"");
quote(ml, "| 1153n -> \"cKA_ENCODING_METHODS\"");
quote(ml, "| 1154n -> \"cKA_MIME_TYPES\"");
quote(ml, "| 1280n -> \"cKA_MECHANISM_TYPE\"");
quote(ml, "| 1281n -> \"cKA_REQUIRED_CMS_ATTRIBUTES\"");
quote(ml, "| 1282n -> \"cKA_DEFAULT_CMS_ATTRIBUTES\"");
quote(ml, "| 1283n -> \"cKA_SUPPORTED_CMS_ATTRIBUTES\"");
quote(ml, "| 1073742353n -> \"cKA_WRAP_TEMPLATE\"");
quote(ml, "| 1073742354n -> \"cKA_UNWRAP_TEMPLATE\"");
quote(ml, "| 1073743360n -> \"cKA_ALLOWED_MECHANISMS\"");
#if __LP64__
quote(ml, "| 2147483648n -> \"cKA_VENDOR_DEFINED\"");
#else
quote(ml, "| -2147483648n -> \"cKA_VENDOR_DEFINED\"");
#endif
quote(ml, "| _ -> \"cKA_UNKNOWN!\"");

quote(ml, "let match_cKS_value a = match a with");
quote(ml, "| 0n -> \"cKS_RO_PUBLIC_SESSION\"");
quote(ml, "| 1n -> \"cKS_RO_USER_FUNCTIONS\"");
quote(ml, "| 2n -> \"cKS_RW_PUBLIC_SESSION\"");
quote(ml, "| 3n -> \"cKS_RW_USER_FUNCTIONS\"");
quote(ml, "| 4n -> \"cKS_RW_SO_FUNCTIONS\"");
quote(ml, "| _ -> \"cKS_UNKNOWN!\"");

quote(ml, "let match_cKH_value a = match a with");
quote(ml, "| 1n -> \"cKH_MONOTONIC_COUNTER\"");
quote(ml, "| 2n -> \"cKH_CLOCK\"");
quote(ml, "| 3n -> \"cKH_USER_INTERFACE\"");
#if __LP64__
quote(ml, "| 2147483648n -> \"cKH_VENDOR_DEFINED\"");
#else
quote(ml, "| -2147483648n -> \"cKH_VENDOR_DEFINED\"");
#endif
quote(ml, "| _ -> \"cKH_UNKNOWN!\"");

quote(ml, "let match_cKK_value a = match a with");
quote(ml, "| 0n -> \"cKK_RSA\"");
quote(ml, "| 1n -> \"cKK_DSA\"");
quote(ml, "| 2n -> \"cKK_DH\"");
quote(ml, "| 3n -> \"cKK_EC\"");
quote(ml, "| 4n -> \"cKK_X9_42_DH\"");
quote(ml, "| 5n -> \"cKK_KEA\"");
quote(ml, "| 16n -> \"cKK_GENERIC_SECRET\"");
quote(ml, "| 17n -> \"cKK_RC2\"");
quote(ml, "| 18n -> \"cKK_RC4\"");
quote(ml, "| 19n -> \"cKK_DES\"");
quote(ml, "| 20n -> \"cKK_DES2\"");
quote(ml, "| 21n -> \"cKK_DES3\"");
quote(ml, "| 22n -> \"cKK_CAST\"");
quote(ml, "| 23n -> \"cKK_CAST3\"");
quote(ml, "| 24n -> \"cKK_CAST128\"");
quote(ml, "| 25n -> \"cKK_RC5\"");
quote(ml, "| 26n -> \"cKK_IDEA\"");
quote(ml, "| 27n -> \"cKK_SKIPJACK\"");
quote(ml, "| 28n -> \"cKK_BATON\"");
quote(ml, "| 29n -> \"cKK_JUNIPER\"");
quote(ml, "| 30n -> \"cKK_CDMF\"");
quote(ml, "| 31n -> \"cKK_AES\"");
quote(ml, "| 32n -> \"cKK_BLOWFISH\"");
quote(ml, "| 33n -> \"cKK_TWOFISH\"");
#if __LP64__
quote(ml, "| 2147483648n -> \"cKK_VENDOR_DEFINED\"");
#else
quote(ml, "| -2147483648n -> \"cKK_VENDOR_DEFINED\"");
#endif
quote(ml, "| _ -> \"cKK_UNKNOWN!\"");

quote(ml, "let match_cKC_value a = match a with");
quote(ml, "| 0n -> \"cKC_X_509\"");
quote(ml, "| 1n -> \"cKC_X_509_ATTR_CERT\"");
quote(ml, "| 2n -> \"cKC_WTLS\"");
#if __LP64__
quote(ml, "| 2147483648n -> \"cKC_VENDOR_DEFINED\"");
#else
quote(ml, "| -2147483648n -> \"cKC_VENDOR_DEFINED\"");
#endif
quote(ml, "| _ -> \"cKC_UNKNOWN!\"");

/* Helpers for OCaml programs */
quote(mli, "(* Helpers for information printing *)\n");
quote(mli, "val match_cKM_value : nativeint -> string\n");
quote(mli, "val match_cKR_value : nativeint -> string\n");
quote(mli, "val match_cKA_value : nativeint -> string\n");
quote(mli, "val match_cKF_value : nativeint -> string\n");
quote(mli, "val match_cKC_value : nativeint -> string\n");
quote(mli, "val match_cKK_value : nativeint -> string\n");
quote(mli, "val match_cKS_value : nativeint -> string\n");
quote(mli, "val match_cKU_value : nativeint -> string\n");
quote(mli, "val match_cKO_value : nativeint -> string\n");
quote(mli, "val string_to_cKM_value : string -> nativeint\n");

quote(mli, "(* Helpers for strings and char arrays *)\n");
quote(mli, "val string_to_char_array : string -> char array\n");
quote(mli, "val char_array_to_string : char array -> string\n");
quote(mli, "val print_int_array : nativeint array -> unit\n");
quote(mli, "val print_char_array : char array -> unit\n");
quote(mli, "val print_string_array : string array -> unit\n");
quote(mli, "val print_hex : char -> unit\n");
quote(mli, "val print_hex_array : char array -> unit\n");
quote(mli, "val int_to_hexchar : nativeint -> char\n");
quote(mli, "val hexchar_to_int : char -> nativeint\n");
quote(mli, "val merge_nibbles : char -> char -> char\n");
quote(mli, "val pack : string -> string\n");
quote(mli, "val sprint_hex_array : char array -> string\n");
quote(mli, "val bool_to_char_array : nativeint -> char array\n");
quote(mli, "val char_array_to_bool : char array -> nativeint\n");
quote(mli, "val sprint_bool_attribute_value : nativeint -> string\n");
quote(mli, "val sprint_template_array : ck_attribute array -> string\n");

quote(ml,
      "let char_array_to_string = fun a -> let s = String.create (Array.length a) in\n");
quote(ml, "  Array.iteri (fun i x -> String.set s i x) a; s;;\n");

quote(ml,
      "let string_to_char_array = fun s -> Array.init (String.length s) (fun i -> s.[i]);;\n");

quote(ml,
      "let print_int_array = fun a -> Printf.printf \"'\"; Array.iter (fun str -> Printf.printf \"%s \" (Nativeint.to_string str)) a; Printf.printf \"'\\n\";;");
quote(ml,
      "let print_char_array = fun a -> Printf.printf \"'\"; Array.iter (Printf.printf \"%c\") a; Printf.printf \"'\\n\";;");
quote(ml,
      "let print_string_array = fun a -> Printf.printf \"'\"; Array.iter (Printf.printf \"%s | \") a; Printf.printf \"'\\n\";;");
quote(ml, "let print_hex = fun a -> Printf.printf \"%02x\" (int_of_char a);;");
quote(ml,
      "let print_hex_array = fun a -> Printf.printf \"'\"; Array.iter print_hex a; Printf.printf \"'\\n\";;");
quote(ml, "let int_to_hexchar (i : nativeint) : char =");
quote(ml, "   match i with");
quote(ml, "     0n -> '0'");
quote(ml, "   | 1n -> '1'");
quote(ml, "   | 2n -> '2'");
quote(ml, "   | 3n -> '3'");
quote(ml, "   | 4n -> '4'");
quote(ml, "   | 5n -> '5'");
quote(ml, "   | 6n -> '6'");
quote(ml, "   | 7n -> '7'");
quote(ml, "   | 8n -> '8'");
quote(ml, "   | 9n -> '9'");
quote(ml, "   | 10n -> 'a'");
quote(ml, "   | 11n -> 'b'");
quote(ml, "   | 12n -> 'c'");
quote(ml, "   | 13n -> 'd'");
quote(ml, "   | 14n -> 'e'");
quote(ml, "   | 15n -> 'f'");
quote(ml, "   | _ -> failwith \"int_to_hexchar\";;\n");

quote(ml, "let hexchar_to_int (c : char) : nativeint =");
quote(ml, "   match c with");
quote(ml, "     '0' -> 0n");
quote(ml, "   | '1' -> 1n");
quote(ml, "   | '2' -> 2n");
quote(ml, "   | '3' -> 3n");
quote(ml, "   | '4' -> 4n");
quote(ml, "   | '5' -> 5n");
quote(ml, "   | '6' -> 6n");
quote(ml, "   | '7' -> 7n");
quote(ml, "   | '8' -> 8n");
quote(ml, "   | '9' -> 9n");
quote(ml, "   | 'a' -> 10n");
quote(ml, "   | 'b' -> 11n");
quote(ml, "   | 'c' -> 12n");
quote(ml, "   | 'd' -> 13n");
quote(ml, "   | 'e' -> 14n");
quote(ml, "   | 'f' -> 15n");
quote(ml, "   | 'A' -> 10n");
quote(ml, "   | 'B' -> 11n");
quote(ml, "   | 'C' -> 12n");
quote(ml, "   | 'D' -> 13n");
quote(ml, "   | 'E' -> 14n");
quote(ml, "   | 'F' -> 15n");
quote(ml, "   | _ -> failwith \"hexchar_to_int\";;\n");

quote(ml, "let merge_nibbles niba nibb =");
quote(ml, "    let ciba = hexchar_to_int nibb in");
quote(ml, "    let cibb = hexchar_to_int niba in");
quote(ml, "    let res = (Nativeint.shift_left cibb 4) in");
quote(ml, "    let res = (Nativeint.logxor res ciba) in");
quote(ml, "    let res = Char.chr (Nativeint.to_int res) in");
quote(ml, "    (res);;");

quote(ml, "let pack hexstr =");
quote(ml, "     let len = String.length hexstr in");
quote(ml, "     let half_len = len / 2 in");
quote(ml, "     let res = String.create half_len in");
quote(ml, "     let j = ref 0 in");
quote(ml, "     for i = 0 to len - 2 do");
quote(ml, "        if (i mod 2 == 0) then");
quote(ml, "          (");
quote(ml, "          let tmp = merge_nibbles hexstr.[i] hexstr.[i+1] in");
quote(ml, "          res.[!j] <- tmp;");
quote(ml, "          j := !j +1;");
quote(ml, "          )");
quote(ml, "     done;");
quote(ml, "     (res);;");

quote(ml, "let sprint_hex_array myarray =");
quote(ml, "  let s = Array.fold_left (");
quote(ml, "    fun a elem -> Printf.sprintf \"%s%02x\" a (int_of_char elem);");
quote(ml, "  ) \"'\" myarray in");
quote(ml, "  (Printf.sprintf \"%s'\" s)");
quote(ml, "");

quote(ml, "let bool_to_char_array boolean_attribute =");
quote(ml, "  if compare boolean_attribute cK_FALSE = 0 then");
quote(ml, "    ([| (Char.chr 0) |])");
quote(ml, "  else");
quote(ml, "    ([| (Char.chr 1) |])");
quote(ml, "");

quote(ml, "let char_array_to_bool char_array =");
quote(ml, "  let check = Array.fold_left (");
quote(ml, "    fun curr_check elem ->");
quote(ml, "      if compare elem (Char.chr 0) = 0 then");
quote(ml, "        (curr_check || false)");
quote(ml, "      else");
quote(ml, "        (curr_check || true)");
quote(ml, "    ) false char_array in");
quote(ml, "  if compare check false = 0 then");
quote(ml, "    (cK_FALSE)");
quote(ml, "  else");
quote(ml, "    (cK_TRUE)");
quote(ml, "");

quote(ml, "let sprint_bool_attribute_value attribute_value =");
quote(ml, "  if compare attribute_value cK_TRUE = 0 then");
quote(ml, "    (\"TRUE\")");
quote(ml, "  else");
quote(ml, "    if compare attribute_value cK_FALSE = 0 then");
quote(ml, "      (\"FALSE\")");
quote(ml, "    else");
quote(ml, "      (\"UNKNOWN!\")");
quote(ml, "");

quote(ml, "let sprint_template_array template_array =");
quote(ml, "  let string_ = Array.fold_left");
quote(ml, "    (fun curr_string templ ->");
quote(ml, "       let s1 = Printf.sprintf \"(%s, \" (match_cKA_value templ.type_) in");
quote(ml, "       let s2 = Printf.sprintf \"%s) \" (sprint_hex_array templ.value) in");
quote(ml, "       (String.concat \"\" [curr_string; s1; s2])");
quote(ml, "  ) \"\" template_array in");
quote(ml, "  (string_)");


typedef unsigned char CK_BYTE;
typedef unsigned char CK_CHAR;
typedef unsigned char CK_UTF8CHAR;
typedef unsigned char CK_BBOOL;
typedef[nativeint]
unsigned long int CK_ULONG;
typedef[nativeint]
long int CK_LONG;
typedef CK_BYTE *CK_BYTE_PTR;
typedef CK_CHAR *CK_CHAR_PTR;
typedef CK_UTF8CHAR *CK_UTF8CHAR_PTR;
typedef CK_ULONG *CK_ULONG_PTR;

#define CK_FALSE 0
#define CK_TRUE 1
#ifndef CK_DISABLE_TRUE_FALSE
#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif
#endif

typedef struct ck_version CK_VERSION;
typedef struct ck_version *CK_VERSION_PTR;

typedef struct ck_info CK_INFO;
typedef struct ck_info *CK_INFO_PTR;

typedef ck_slot_id_t *CK_SLOT_ID_PTR;

typedef struct ck_slot_info CK_SLOT_INFO;
typedef struct ck_slot_info *CK_SLOT_INFO_PTR;

typedef struct ck_token_info CK_TOKEN_INFO;
typedef struct ck_token_info *CK_TOKEN_INFO_PTR;

typedef ck_session_handle_t *CK_SESSION_HANDLE_PTR;

typedef struct ck_session_info CK_SESSION_INFO;
typedef struct ck_session_info *CK_SESSION_INFO_PTR;

typedef ck_object_handle_t *CK_OBJECT_HANDLE_PTR;

typedef ck_object_class_t *CK_OBJECT_CLASS_PTR;

typedef struct ck_attribute CK_ATTRIBUTE;
typedef struct ck_attribute *CK_ATTRIBUTE_PTR;

typedef struct ck_date CK_DATE;
typedef struct ck_date *CK_DATE_PTR;

typedef ck_mechanism_type_t *CK_MECHANISM_TYPE_PTR;

typedef struct ck_mechanism CK_MECHANISM;
typedef struct ck_mechanism *CK_MECHANISM_PTR;

typedef struct ck_mechanism_info CK_MECHANISM_INFO;
typedef struct ck_mechanism_info *CK_MECHANISM_INFO_PTR;

typedef struct ck_c_initialize_args CK_C_INITIALIZE_ARGS;
typedef struct ck_c_initialize_args *CK_C_INITIALIZE_ARGS_PTR;

#define NULL_PTR NULL

/*********** Tricky structures **************************/
typedef[nativeint]
unsigned long ck_rv_t;

/*typedef ck_rv_t (*ck_createmutex_t) (void **mutex);
typedef ck_rv_t (*ck_destroymutex_t) (void *mutex);
typedef ck_rv_t (*ck_lockmutex_t) (void *mutex);
typedef ck_rv_t (*ck_unlockmutex_t) (void *mutex);*/
typedef[abstract, mltype("unit->nativeint")]
int (*ck_createmutex_t);
typedef[abstract, mltype("unit->nativeint")]
int (*ck_destroymutex_t);
typedef[abstract, mltype("unit->nativeint")]
int (*ck_lockmutex_t);
typedef[abstract, mltype("unit->nativeint")]
int (*ck_unlockmutex_t);

struct ck_c_initialize_args {
  ck_createmutex_t create_mutex;
  ck_destroymutex_t destroy_mutex;
  ck_lockmutex_t lock_mutex;
  ck_unlockmutex_t unlock_mutex;
  ck_flags_t flags;
  /* Don't take care of the reserved field, it will be at NULL
     when calling the PKCS11 API */
  [ignore] void *reserved;
};

/* The MAX_BUFF_LEN is used to avoid, when possible, allocating */
/* data on the heap. This is mainly used for PKCS#11 functions  */
/* that are expected to return small amount of data, such as    */
/* digest or signature data                                     */
#define MAX_BUFF_LEN 16384
quote(C, "#define MAX_BUFF_LEN 16384\n");
quote(C, "#define CKR_OK					(0UL)\n");

/*********** PKCS11 API **************************/
#define _ML_CK_DECLARE_FUNCTION(name, args)	\
ck_rv_t ML_CK_ ## name args		\

_ML_CK_DECLARE_FUNCTION(C_Daemonize,
			([size_is(param_len), in] unsigned char param[],
			 unsigned long param_len));

_ML_CK_DECLARE_FUNCTION(C_SetupArch, ([nativeint] unsigned int arch));

/* C_LoadModule is added and replaces C_GetFunctionList */
_ML_CK_DECLARE_FUNCTION(C_LoadModule,
			([null_terminated, in] unsigned char libname[]));

_ML_CK_DECLARE_FUNCTION(C_Initialize, (void));

_ML_CK_DECLARE_FUNCTION(C_Finalize, (void));

_ML_CK_DECLARE_FUNCTION(C_GetSlotList,
			([nativeint] unsigned int token_present,
			 [size_is(count), out] ck_slot_id_t slot_list[],
			 [nativeint] unsigned long count,
			 [out] unsigned long *real_count));

_ML_CK_DECLARE_FUNCTION(C_GetInfo, ([out] struct ck_info * info));

_ML_CK_DECLARE_FUNCTION(C_WaitForSlotEvent,
			(ck_flags_t flags,[out] ck_slot_id_t * slot_id));

_ML_CK_DECLARE_FUNCTION(C_GetSlotInfo,
			(ck_slot_id_t slot_id,
			 [out] struct ck_slot_info * info));

_ML_CK_DECLARE_FUNCTION(C_GetTokenInfo,
			(ck_slot_id_t slot_id,
			 [out] struct ck_token_info * info));

_ML_CK_DECLARE_FUNCTION(C_InitToken,
			(ck_slot_id_t slot_id,
			 [size_is(pin_len), in] unsigned char pin[],
			 unsigned long pin_len,[null_terminated,
						in] unsigned char label[]));

_ML_CK_DECLARE_FUNCTION(C_OpenSession,
			(ck_slot_id_t slot_id, ck_flags_t flags,
			 [out] ck_session_handle_t * session));

_ML_CK_DECLARE_FUNCTION(C_CloseSession, (ck_session_handle_t session));

_ML_CK_DECLARE_FUNCTION(C_CloseAllSessions, (ck_slot_id_t slot_id));

_ML_CK_DECLARE_FUNCTION(C_GetSessionInfo,
			(ck_session_handle_t session,
			 [out] struct ck_session_info * info));

_ML_CK_DECLARE_FUNCTION(C_Login,
			(ck_session_handle_t session, ck_user_type_t user_type,
			 [size_is(pin_len), in] unsigned char pin[],
			 unsigned long pin_len));

_ML_CK_DECLARE_FUNCTION(C_Logout, (ck_session_handle_t session));

_ML_CK_DECLARE_FUNCTION(C_GetMechanismList,
			(ck_slot_id_t slot_id,
			 [size_is(count),
			  out] ck_mechanism_type_t mechanism_list[],
			 [nativeint] unsigned long count,
			 [out] unsigned long *real_count));

_ML_CK_DECLARE_FUNCTION(C_GetMechanismInfo,
			(ck_slot_id_t slot_id, ck_mechanism_type_t mechanism,
			 [out] struct ck_mechanism_info * info));

_ML_CK_DECLARE_FUNCTION(C_InitPIN,
			(ck_session_handle_t session,
			 [size_is(pin_len), in] unsigned char pin[],
			 unsigned long pin_len));

_ML_CK_DECLARE_FUNCTION(C_SetPIN,
			(ck_session_handle_t session,
			 [size_is(old_pin_len), in] unsigned char old_pin[],
			 unsigned long old_pin_len,[size_is(new_pin_len),
						    in] unsigned char new_pin[],
			 unsigned long new_pin_len));

_ML_CK_DECLARE_FUNCTION(C_SeedRandom,
			(ck_session_handle_t session,
			 [size_is(seed_len), in] unsigned char seed[],
			 unsigned long seed_len));

_ML_CK_DECLARE_FUNCTION(C_GenerateRandom,
			(ck_session_handle_t session,
			 [size_is(rand_len), out] unsigned char rand_value[],
			 [nativeint] unsigned long rand_len));

_ML_CK_DECLARE_FUNCTION(C_FindObjectsInit,
			(ck_session_handle_t session,
			 [size_is(count), in] struct ck_attribute templ[],
			 [nativeint] unsigned long count));

_ML_CK_DECLARE_FUNCTION(C_FindObjects,
			(ck_session_handle_t session,
			 [size_is(max_object_count),
			  out] ck_object_handle_t object[],
			 [nativeint] unsigned long max_object_count,
			 [out] unsigned long *object_count));

_ML_CK_DECLARE_FUNCTION(C_FindObjectsFinal, (ck_session_handle_t session));

_ML_CK_DECLARE_FUNCTION(C_GenerateKey,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 [size_is(count), in] struct ck_attribute templ[],
			 [nativeint] unsigned long count,
			 [out] ck_object_handle_t * phkey));

_ML_CK_DECLARE_FUNCTION(C_GenerateKeyPair,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 [size_is(pub_count),
			  in] struct ck_attribute pub_templ[],
			 [nativeint] unsigned long pub_count,
			 [size_is(priv_count),
			  in] struct ck_attribute priv_templ[],
			 [nativeint] unsigned long priv_count,
			 [out] ck_object_handle_t * phpubkey,
			 [out] ck_object_handle_t * phprivkey));

_ML_CK_DECLARE_FUNCTION(C_CreateObject,
			(ck_session_handle_t session,
			 [size_is(count), in] struct ck_attribute templ[],
			 [nativeint] unsigned long count,
			 [out] ck_object_handle_t * phobject));

_ML_CK_DECLARE_FUNCTION(C_CopyObject,
			(ck_session_handle_t session,
			 ck_object_handle_t hobject,[size_is(count),
						     in] struct ck_attribute
			 templ[],[nativeint] unsigned long count,
			 [out] ck_object_handle_t * phnewobject));

_ML_CK_DECLARE_FUNCTION(C_DestroyObject,
			(ck_session_handle_t session,
			 [in] ck_object_handle_t hobject));

_ML_CK_DECLARE_FUNCTION(C_GetAttributeValue,
			(ck_session_handle_t session,
			 ck_object_handle_t hobject,[size_is(count), in,
						     out] struct ck_attribute
			 templ[],[nativeint] unsigned long count));

_ML_CK_DECLARE_FUNCTION(C_SetAttributeValue,
			(ck_session_handle_t session,
			 ck_object_handle_t hobject,[size_is(count),
						     in] struct ck_attribute
			 templ[],[nativeint] unsigned long count));

_ML_CK_DECLARE_FUNCTION(C_GetObjectSize,
			(ck_session_handle_t session,
			 ck_object_handle_t hobject,
			 [out] unsigned long *object_size));

_ML_CK_DECLARE_FUNCTION(C_WrapKey,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 ck_object_handle_t hwrappingkey,
			 ck_object_handle_t hkey,[size_is(*wrapped_key_len),
						  out] unsigned char
			 wrapped_key[],
			 [ignore] unsigned long *wrapped_key_len));

_ML_CK_DECLARE_FUNCTION(C_UnwrapKey,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 ck_object_handle_t hunwrappingkey,
			 [size_is(wrapped_key_len),
			  in] unsigned char wrapped_key[],
			 unsigned long wrapped_key_len,[size_is(count),
							in] struct ck_attribute
			 templ[],[nativeint] unsigned long count,
			 [out] ck_object_handle_t * phobject));

_ML_CK_DECLARE_FUNCTION(C_DeriveKey,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 ck_object_handle_t hbasekey,[size_is(count),
						      in] struct ck_attribute
			 templ[],[nativeint] unsigned long count,
			 [out] ck_object_handle_t * phkey));

_ML_CK_DECLARE_FUNCTION(C_DigestInit,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism));

_ML_CK_DECLARE_FUNCTION(C_Digest,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len,
			 [size_is(*digest_len), out] unsigned char digest[],
			 [ignore] unsigned long *digest_len));

_ML_CK_DECLARE_FUNCTION(C_DigestUpdate,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len));

_ML_CK_DECLARE_FUNCTION(C_DigestKey,
			(ck_session_handle_t session, ck_object_handle_t hkey));

_ML_CK_DECLARE_FUNCTION(C_DigestFinal,
			(ck_session_handle_t session,
			 [size_is(*digest_len), out] unsigned char digest[],
			 [ignore] unsigned long *digest_len));

_ML_CK_DECLARE_FUNCTION(C_SignInit,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 ck_object_handle_t hkey));

_ML_CK_DECLARE_FUNCTION(C_SignRecoverInit,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 ck_object_handle_t hkey));

_ML_CK_DECLARE_FUNCTION(C_Sign,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len,
			 [size_is(*signed_len), out] unsigned char signature[],
			 [ignore] unsigned long *signed_len));

_ML_CK_DECLARE_FUNCTION(C_SignRecover,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len,
			 [size_is(*signed_len), out] unsigned char signature[],
			 [ignore] unsigned long *signed_len));

_ML_CK_DECLARE_FUNCTION(C_SignUpdate,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len));

_ML_CK_DECLARE_FUNCTION(C_SignFinal,
			(ck_session_handle_t session,
			 [size_is(*signed_len), out] unsigned char signature[],
			 [ignore] unsigned long *signed_len));

_ML_CK_DECLARE_FUNCTION(C_VerifyInit,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 ck_object_handle_t hkey));

_ML_CK_DECLARE_FUNCTION(C_VerifyRecoverInit,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 ck_object_handle_t hkey));

_ML_CK_DECLARE_FUNCTION(C_Verify,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len,
			 [size_is(signed_len), in] unsigned char signature[],
			 unsigned long signed_len));

_ML_CK_DECLARE_FUNCTION(C_VerifyRecover,
			(ck_session_handle_t session,
			 [size_is(signature_len), in] unsigned char signature[],
			 unsigned long signature_len,[size_is(*data_len),
						      out] unsigned char data[],
			 [ignore] unsigned long *data_len));

_ML_CK_DECLARE_FUNCTION(C_VerifyUpdate,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len));

_ML_CK_DECLARE_FUNCTION(C_VerifyFinal,
			(ck_session_handle_t session,
			 [size_is(signed_len), in] unsigned char signature[],
			 unsigned long signed_len));

_ML_CK_DECLARE_FUNCTION(C_EncryptInit,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 ck_object_handle_t hkey));

_ML_CK_DECLARE_FUNCTION(C_Encrypt,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len,
			 [size_is(*encrypted_len),
			  out] unsigned char encrypted[],
			 [ignore] unsigned long *encrypted_len));

_ML_CK_DECLARE_FUNCTION(C_EncryptUpdate,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len,
			 [size_is(*encrypted_len),
			  out] unsigned char encrypted[],
			 [ignore] unsigned long *encrypted_len));

_ML_CK_DECLARE_FUNCTION(C_EncryptFinal,
			(ck_session_handle_t session,
			 [size_is(*encrypted_len),
			  out] unsigned char encrypted[],
			 [ignore] unsigned long *encrypted_len));

_ML_CK_DECLARE_FUNCTION(C_DigestEncryptUpdate,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len,
			 [size_is(*encrypted_len),
			  out] unsigned char encrypted[],
			 [ignore] unsigned long *encrypted_len));

_ML_CK_DECLARE_FUNCTION(C_SignEncryptUpdate,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len,
			 [size_is(*encrypted_len),
			  out] unsigned char encrypted[],
			 [ignore] unsigned long *encrypted_len));

_ML_CK_DECLARE_FUNCTION(C_DecryptInit,
			(ck_session_handle_t session,
			 struct ck_mechanism mechanism,
			 ck_object_handle_t hkey));

_ML_CK_DECLARE_FUNCTION(C_Decrypt,
			(ck_session_handle_t session,
			 [size_is(encrypted_len), in] unsigned char encrypted[],
			 [nativeint] unsigned long encrypted_len,
			 [size_is(*decrypted_len),
			  out] unsigned char decrypted[],
			 [ignore] unsigned long *decrypted_len));

_ML_CK_DECLARE_FUNCTION(C_DecryptUpdate,
			(ck_session_handle_t session,
			 [size_is(encrypted_len), in] unsigned char encrypted[],
			 [nativeint] unsigned long encrypted_len,
			 [size_is(*data_len), out] unsigned char data[],
			 [ignore] unsigned long *data_len));

_ML_CK_DECLARE_FUNCTION(C_DecryptFinal,
			(ck_session_handle_t session,
			 [size_is(*decrypted_len),
			  out] unsigned char decrypted[],
			 [ignore] unsigned long *decrypted_len));

_ML_CK_DECLARE_FUNCTION(C_DecryptDigestUpdate,
			(ck_session_handle_t session,
			 [size_is(encrypted_len), in] unsigned char encrypted[],
			 [nativeint] unsigned long encrypted_len,
			 [size_is(*data_len), out] unsigned char data[],
			 [ignore] unsigned long *data_len));

_ML_CK_DECLARE_FUNCTION(C_DecryptVerifyUpdate,
			(ck_session_handle_t session,
			 [size_is(encrypted_len), in] unsigned char encrypted[],
			 [nativeint] unsigned long encrypted_len,
			 [size_is(*data_len), out] unsigned char data[],
			 [ignore] unsigned long *data_len));

_ML_CK_DECLARE_FUNCTION(C_GetOperationState,
			(ck_session_handle_t session,
			 [size_is(*data_len), out] unsigned char data[],
			 [ignore] unsigned long *data_len));

_ML_CK_DECLARE_FUNCTION(C_SetOperationState,
			(ck_session_handle_t session,
			 [size_is(data_len), in] unsigned char data[],
			 [nativeint] unsigned long data_len,
			 ck_object_handle_t hencryptionkey,
			 ck_object_handle_t hauthenticationkey));

/* Deprecated functions */
_ML_CK_DECLARE_FUNCTION(C_GetFunctionStatus, (ck_session_handle_t session));

_ML_CK_DECLARE_FUNCTION(C_CancelFunction, (ck_session_handle_t session));

/* Specific functions to handle architecture issues (32 versus 64 bit ulong, endianness ...) */
void int_to_ulong_char_array([nativeint]
			     unsigned long input,
			     [size_is(sizeof(unsigned long)), out]
			     unsigned char data[]);

void char_array_to_ulong([in]unsigned char data[], 
                             [nativeint, out]unsigned long output);

void hton_char_array([in]unsigned char in[], 
	             [size_is(*out_len), out]unsigned char out[],
                     [ignore]unsigned long* out_len);

void ntoh_char_array([in]unsigned char in[], 
	             [size_is(*out_len), out]unsigned char out[],
                     [ignore]unsigned long* out_len);


/* pkcs11_stubs.c */
quote(H,"/* Avoid declaring caml stuff when sharing this header with C rpc client code */");
quote(H,"#if !defined(CRPC)");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_flags_t(value _v1, ck_flags_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_flags_t(ck_flags_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_struct_ck_version(value _v1, struct ck_version *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_struct_ck_version(struct ck_version *_c1, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_struct_ck_info(value _v1, struct ck_info *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_struct_ck_info(struct ck_info *_c1, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_notification_t(value _v1, ck_notification_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_notification_t(ck_notification_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_slot_id_t(value _v1, ck_slot_id_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_slot_id_t(ck_slot_id_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_struct_ck_slot_info(value _v1, struct ck_slot_info *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_struct_ck_slot_info(struct ck_slot_info *_c1, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_struct_ck_token_info(value _v1, struct ck_token_info *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_struct_ck_token_info(struct ck_token_info *_c1, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_session_handle_t(value _v1, ck_session_handle_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_session_handle_t(ck_session_handle_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_user_type_t(value _v1, ck_user_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_user_type_t(ck_user_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_state_t(value _v1, ck_state_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_state_t(ck_state_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_struct_ck_session_info(value _v1, struct ck_session_info *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_struct_ck_session_info(struct ck_session_info *_c1, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_object_handle_t(value _v1, ck_object_handle_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_object_handle_t(ck_object_handle_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_object_class_t(value _v1, ck_object_class_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_object_class_t(ck_object_class_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_hw_feature_type_t(value _v1, ck_hw_feature_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_hw_feature_type_t(ck_hw_feature_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_key_type_t(value _v1, ck_key_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_key_type_t(ck_key_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_certificate_type_t(value _v1, ck_certificate_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_certificate_type_t(ck_certificate_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_attribute_type_t(value _v1, ck_attribute_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_attribute_type_t(ck_attribute_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_struct_ck_attribute(value _v1, struct ck_attribute *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_struct_ck_attribute(struct ck_attribute *_c1, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_struct_ck_date(value _v1, struct ck_date *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_struct_ck_date(struct ck_date *_c1, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_mechanism_type_t(value _v1, ck_mechanism_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_mechanism_type_t(ck_mechanism_type_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_struct_ck_mechanism(value _v1, struct ck_mechanism *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_struct_ck_mechanism(struct ck_mechanism *_c1, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_struct_ck_mechanism_info(value _v1, struct ck_mechanism_info *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_struct_ck_mechanism_info(struct ck_mechanism_info *_c1, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_BYTE(value _v1, CK_BYTE *_c2, camlidl_ctx _ctx);");
quote(H, "value camlidl_c2ml_pkcs11_CK_BYTE(CK_BYTE *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_CHAR(value _v1, CK_CHAR *_c2, camlidl_ctx _ctx);");
quote(H, "value camlidl_c2ml_pkcs11_CK_CHAR(CK_CHAR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_UTF8CHAR(value _v1, CK_UTF8CHAR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_UTF8CHAR(CK_UTF8CHAR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_BBOOL(value _v1, CK_BBOOL *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_BBOOL(CK_BBOOL *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_ULONG(value _v1, CK_ULONG *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_ULONG(CK_ULONG *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_LONG(value _v1, CK_LONG *_c2, camlidl_ctx _ctx);");
quote(H, "value camlidl_c2ml_pkcs11_CK_LONG(CK_LONG *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_BYTE_PTR(value _v1, CK_BYTE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_BYTE_PTR(CK_BYTE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_CHAR_PTR(value _v1, CK_CHAR_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_CHAR_PTR(CK_CHAR_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_UTF8CHAR_PTR(value _v1, CK_UTF8CHAR_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_UTF8CHAR_PTR(CK_UTF8CHAR_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_ULONG_PTR(value _v1, CK_ULONG_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_ULONG_PTR(CK_ULONG_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_VERSION(value _v1, CK_VERSION *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_VERSION(CK_VERSION *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_VERSION_PTR(value _v1, CK_VERSION_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_VERSION_PTR(CK_VERSION_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_INFO(value _v1, CK_INFO *_c2, camlidl_ctx _ctx);");
quote(H, "value camlidl_c2ml_pkcs11_CK_INFO(CK_INFO *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_INFO_PTR(value _v1, CK_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_INFO_PTR(CK_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_SLOT_ID_PTR(value _v1, CK_SLOT_ID_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_SLOT_ID_PTR(CK_SLOT_ID_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_SLOT_INFO(value _v1, CK_SLOT_INFO *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_SLOT_INFO(CK_SLOT_INFO *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_SLOT_INFO_PTR(value _v1, CK_SLOT_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_SLOT_INFO_PTR(CK_SLOT_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_TOKEN_INFO(value _v1, CK_TOKEN_INFO *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_TOKEN_INFO(CK_TOKEN_INFO *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_TOKEN_INFO_PTR(value _v1, CK_TOKEN_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_TOKEN_INFO_PTR(CK_TOKEN_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_SESSION_HANDLE_PTR(value _v1, CK_SESSION_HANDLE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_SESSION_HANDLE_PTR(CK_SESSION_HANDLE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_SESSION_INFO(value _v1, CK_SESSION_INFO *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_SESSION_INFO(CK_SESSION_INFO *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_SESSION_INFO_PTR(value _v1, CK_SESSION_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_SESSION_INFO_PTR(CK_SESSION_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_OBJECT_HANDLE_PTR(value _v1, CK_OBJECT_HANDLE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_OBJECT_HANDLE_PTR(CK_OBJECT_HANDLE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_OBJECT_CLASS_PTR(value _v1, CK_OBJECT_CLASS_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_OBJECT_CLASS_PTR(CK_OBJECT_CLASS_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_ATTRIBUTE(value _v1, CK_ATTRIBUTE *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_ATTRIBUTE(CK_ATTRIBUTE *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_ATTRIBUTE_PTR(value _v1, CK_ATTRIBUTE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_ATTRIBUTE_PTR(CK_ATTRIBUTE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_DATE(value _v1, CK_DATE *_c2, camlidl_ctx _ctx);");
quote(H, "value camlidl_c2ml_pkcs11_CK_DATE(CK_DATE *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_DATE_PTR(value _v1, CK_DATE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_DATE_PTR(CK_DATE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_MECHANISM_TYPE_PTR(value _v1, CK_MECHANISM_TYPE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_MECHANISM_TYPE_PTR(CK_MECHANISM_TYPE_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_MECHANISM(value _v1, CK_MECHANISM *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_MECHANISM(CK_MECHANISM *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_MECHANISM_PTR(value _v1, CK_MECHANISM_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_MECHANISM_PTR(CK_MECHANISM_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_MECHANISM_INFO(value _v1, CK_MECHANISM_INFO *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_MECHANISM_INFO(CK_MECHANISM_INFO *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_MECHANISM_INFO_PTR(value _v1, CK_MECHANISM_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_MECHANISM_INFO_PTR(CK_MECHANISM_INFO_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_C_INITIALIZE_ARGS(value _v1, CK_C_INITIALIZE_ARGS *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_C_INITIALIZE_ARGS(CK_C_INITIALIZE_ARGS *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_CK_C_INITIALIZE_ARGS_PTR(value _v1, CK_C_INITIALIZE_ARGS_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_CK_C_INITIALIZE_ARGS_PTR(CK_C_INITIALIZE_ARGS_PTR *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_rv_t(value _v1, ck_rv_t *_c2, camlidl_ctx _ctx);");
quote(H, "value camlidl_c2ml_pkcs11_ck_rv_t(ck_rv_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_createmutex_t(value _v1, ck_createmutex_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_createmutex_t(ck_createmutex_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_destroymutex_t(value _v1, ck_destroymutex_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_destroymutex_t(ck_destroymutex_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_lockmutex_t(value _v1, ck_lockmutex_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_lockmutex_t(ck_lockmutex_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "void camlidl_ml2c_pkcs11_ck_unlockmutex_t(value _v1, ck_unlockmutex_t *_c2, camlidl_ctx _ctx);");
quote(H,
      "value camlidl_c2ml_pkcs11_ck_unlockmutex_t(ck_unlockmutex_t *_c2, camlidl_ctx _ctx);");
quote(H, "value camlidl_pkcs11_ML_CK_C_Daemonize(value _v_param);");
quote(H, "value camlidl_pkcs11_ML_CK_C_SetupArch(value _v_client_arch);");
quote(H, "value camlidl_pkcs11_ML_CK_C_LoadModule(value _v_libname);");
quote(H, "value camlidl_pkcs11_ML_CK_C_Initialize(value _unit);");
quote(H, "value camlidl_pkcs11_ML_CK_C_Finalize(value _unit);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_GetSlotList(value _v_token_present, value _v_count);");
quote(H, "value camlidl_pkcs11_ML_CK_C_GetInfo(value _unit);");
quote(H, "value camlidl_pkcs11_ML_CK_C_WaitForSlotEvent(value _v_flags);");
quote(H, "value camlidl_pkcs11_ML_CK_C_GetSlotInfo(value _v_slot_id);");
quote(H, "value camlidl_pkcs11_ML_CK_C_GetTokenInfo(value _v_slot_id);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_InitToken(value _v_slot_id, value _v_pin, value _v_label);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_OpenSession(value _v_slot_id, value _v_flags);");
quote(H, "value camlidl_pkcs11_ML_CK_C_CloseSession(value _v_session);");
quote(H, "value camlidl_pkcs11_ML_CK_C_CloseAllSessions(value _v_slot_id);");
quote(H, "value camlidl_pkcs11_ML_CK_C_GetSessionInfo(value _v_session);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_Login(value _v_session, value _v_user_type, value _v_pin);");
quote(H, "value camlidl_pkcs11_ML_CK_C_Logout(value _v_session);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_GetMechanismList(value _v_slot_id, value _v_count);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_GetMechanismInfo(value _v_slot_id, value _v_mechanism);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_InitPIN(value _v_session, value _v_pin);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_SetPIN(value _v_session, value _v_old_pin, value _v_new_pin);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_SeedRandom(value _v_session, value _v_seed);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_GenerateRandom(value _v_session, value _v_rand_len);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_FindObjectsInit(value _v_session, value _v_templ);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_FindObjects(value _v_session, value _v_max_object_count);");
quote(H, "value camlidl_pkcs11_ML_CK_C_FindObjectsFinal(value _v_session);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_GenerateKey(value _v_session, value _v_mechanism, value _v_templ);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_GenerateKeyPair(value _v_session, value _v_mechanism, value _v_pub_templ, value _v_priv_templ);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_CreateObject(value _v_session, value _v_templ);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_CopyObject(value _v_session, value _v_hobject, value _v_templ);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DestroyObject(value _v_session, value _v_hobject);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_GetAttributeValue(value _v_session, value _v_hobject, value _v_templ);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_SetAttributeValue(value _v_session, value _v_hobject, value _v_templ);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_GetObjectSize(value _v_session, value _v_hobject);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_WrapKey(value _v_session, value _v_mechanism, value _v_hwrappingkey, value _v_hkey);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_UnwrapKey(value _v_session, value _v_mechanism, value _v_hunwrappingkey, value _v_wrapped_key, value _v_templ);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DeriveKey(value _v_session, value _v_mechanism, value _v_hbasekey, value _v_templ);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DigestInit(value _v_session, value _v_mechanism);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_Digest(value _v_session, value _v_data);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DigestUpdate(value _v_session, value _v_data);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DigestKey(value _v_session, value _v_hkey);");
quote(H, "value camlidl_pkcs11_ML_CK_C_DigestFinal(value _v_session);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_SignInit(value _v_session, value _v_mechanism, value _v_hkey);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_SignRecoverInit(value _v_session, value _v_mechanism, value _v_hkey);");
quote(H, "value camlidl_pkcs11_ML_CK_C_Sign(value _v_session, value _v_data);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_SignRecover(value _v_session, value _v_data);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_SignUpdate(value _v_session, value _v_data);");
quote(H, "value camlidl_pkcs11_ML_CK_C_SignFinal(value _v_session);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_VerifyInit(value _v_session, value _v_mechanism, value _v_hkey);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_VerifyRecoverInit(value _v_session, value _v_mechanism, value _v_hkey);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_Verify(value _v_session, value _v_data, value _v_signature);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_VerifyRecover(value _v_session, value _v_signature);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_VerifyUpdate(value _v_session, value _v_data);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_VerifyFinal(value _v_session, value _v_signature);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_EncryptInit(value _v_session, value _v_mechanism, value _v_hkey);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_Encrypt(value _v_session, value _v_data);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_EncryptUpdate(value _v_session, value _v_data);");
quote(H, "value camlidl_pkcs11_ML_CK_C_EncryptFinal(value _v_session);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DigestEncryptUpdate(value _v_session, value _v_data);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_SignEncryptUpdate(value _v_session, value _v_data);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DecryptInit(value _v_session, value _v_mechanism, value _v_hkey);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_Decrypt(value _v_session, value _v_encrypted);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DecryptUpdate(value _v_session, value _v_encrypted);");
quote(H, "value camlidl_pkcs11_ML_CK_C_DecryptFinal(value _v_session);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DecryptDigestUpdate(value _v_session, value _v_encrypted);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_DecryptVerifyUpdate(value _v_session, value _v_encrypted);");
quote(H, "value camlidl_pkcs11_ML_CK_C_GetOperationState(value _v_session);");
quote(H,
      "value camlidl_pkcs11_ML_CK_C_SetOperationState(value _v_session, value _v_data, value _v_hencryptionkey, value _v_hauthenticationkey);");
quote(H, "value camlidl_pkcs11_ML_CK_C_GetFunctionStatus(value _v_session);");
quote(H, "value camlidl_pkcs11_ML_CK_C_CancelFunction(value _v_session);");
quote(H, "value camlidl_pkcs11_int_to_ulong_char_array(value _v_input);");
quote(H, "value camlidl_pkcs11_char_array_to_ulong(value _v_data);");
quote(H, "value camlidl_pkcs11_hton_char_array(value _v_data);");
quote(H, "value camlidl_pkcs11_ntoh_char_array(value _v_data);");

quote(H, "#ifdef SERVER_ROLE");
quote(H,
      "int decode_ck_attribute_arch(value , struct ck_attribute *, camlidl_ctx);");
quote(H,
      "int encode_ck_attribute_arch(struct ck_attribute *, struct ck_attribute *);");
quote(H, "#endif");
quote(H, "#endif /* !CRPC */");

quote(C, "#ifdef SERVER_ROLE");
quote(C,
      "int encode_ck_attribute_arch(struct ck_attribute * in, struct ck_attribute * out){");
quote(C, "    uint32_t to_send32;");
quote(C, "    uint64_t to_send64;");
quote(C, "    out->type_ = in->type_;");
quote(C,
      "    if(my_arch == LITTLE_ENDIAN_32 && peer_arch == LITTLE_ENDIAN_32){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint32_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            memcpy(out->value, in->value, sizeof(uint32_t));");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "    }");
quote(C,
      "    if(my_arch == LITTLE_ENDIAN_64 && peer_arch == LITTLE_ENDIAN_32){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint64_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            memcpy(out->value, in->value, sizeof(uint32_t));");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "    }");
quote(C,
      "    if(my_arch == LITTLE_ENDIAN_32 && peer_arch == LITTLE_ENDIAN_64){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint32_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            memcpy(out->value, in->value, sizeof(uint32_t));");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "    }");
quote(C,
      "    if(my_arch == LITTLE_ENDIAN_64 && peer_arch == LITTLE_ENDIAN_64){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint64_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            memcpy(out->value, in->value, sizeof(uint64_t));");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_32 && peer_arch == BIG_ENDIAN_32){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint32_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            memcpy(out->value, in->value, sizeof(uint32_t));");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_64 && peer_arch == BIG_ENDIAN_64){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint32_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            memcpy(out->value, in->value, sizeof(uint64_t));");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == LITTLE_ENDIAN_32 && peer_arch == BIG_ENDIAN_32){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint32_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            to_send32 = htobe32(*((uint32_t*)(in->value)));");
quote(C, "            memcpy(out->value, &to_send32, sizeof(uint32_t));");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_32 && peer_arch == LITTLE_ENDIAN_32){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint32_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            to_send32 = htole32(*((uint32_t*)(in->value)));");
quote(C, "            memcpy(out->value, &to_send32, sizeof(uint32_t));");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == LITTLE_ENDIAN_64 && peer_arch == BIG_ENDIAN_64){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint64_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            to_send64 = htobe64(*((uint64_t*)(in->value)));");
quote(C, "            memcpy(out->value, &to_send64, sizeof(uint64_t));");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_64 && peer_arch == LITTLE_ENDIAN_64){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint64_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            to_send64 = htole64(*((uint64_t*)(in->value)));");
quote(C, "            memcpy(out->value, &to_send64, sizeof(uint64_t));");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == LITTLE_ENDIAN_64 && peer_arch == BIG_ENDIAN_32){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint64_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            /* Endianness is different */");
quote(C, "            to_send32 = htobe32(*((uint32_t*)(in->value)));");
quote(C, "            memcpy(out->value, &to_send32, sizeof(uint32_t));");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_32 && peer_arch == LITTLE_ENDIAN_64){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint32_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            /* Endianness is different */");
quote(C, "            to_send64 = htole64(*((uint32_t*)(in->value)));");
quote(C, "            memcpy(out->value, &to_send64, sizeof(uint64_t));");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == LITTLE_ENDIAN_32 && peer_arch == BIG_ENDIAN_64){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint32_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            /* Endianness is different */");
quote(C, "            to_send64 = htobe64(*((uint32_t*)(in->value)));");
quote(C, "            memcpy(out->value, &to_send64, sizeof(uint64_t));");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_64 && peer_arch == LITTLE_ENDIAN_32){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint64_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            /* Endianness is different */");
quote(C, "            to_send32 = htole32(*((uint32_t*)(in->value+4)));");
quote(C, "            memcpy(out->value, &to_send32, sizeof(uint32_t));");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_32 && peer_arch == BIG_ENDIAN_64){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint32_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            /* Endianness is different */");
quote(C, "            to_send64 = htobe64(*((uint32_t*)(in->value)));");
quote(C, "            memcpy(out->value, &to_send64, sizeof(uint64_t));");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint64_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_64 && peer_arch == BIG_ENDIAN_32){");
quote(C, "        if(in->value != NULL){");
quote(C, "            if(in->value_len != sizeof(uint64_t)){");
quote(C, "                return -1;");
quote(C, "            }");
quote(C, "            /* Endianness is different */");
quote(C, "            to_send32 = htobe32(*((uint32_t*)(in->value+4)));");
quote(C, "            memcpy(out->value, &to_send32, sizeof(uint32_t));");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "        else{");
quote(C, "            out->value = NULL;");
quote(C, "            out->value_len = sizeof(uint32_t);");
quote(C, "        }");
quote(C, "    }");
quote(C, "    return 0;");
quote(C, "}");
quote(C, "#endif");

quote(C, "#ifdef SERVER_ROLE");
quote(C,
      "int decode_ck_attribute_arch(value in, struct ck_attribute * out, camlidl_ctx _ctx){");
quote(C, "    value vtmp;");
quote(C, "    unsigned long counter;");
quote(C, "");
quote(C,
      "    if(my_arch == LITTLE_ENDIAN_32 && peer_arch == LITTLE_ENDIAN_32){");
quote(C, "        if(Wosize_val(in) != sizeof(uint32_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint32_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint32_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint32_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C, "            (*out).value[counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint32_t);");
quote(C, "    }");
quote(C, "");
quote(C,
      "    if(my_arch == LITTLE_ENDIAN_32 && peer_arch == LITTLE_ENDIAN_64){");
quote(C, "        if(Wosize_val(in) != sizeof(uint64_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint64_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint32_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint32_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C, "            (*out).value[counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint32_t);");
quote(C, "    }");
quote(C, "");
quote(C, "    if(my_arch == BIG_ENDIAN_32 && peer_arch == BIG_ENDIAN_64){");
quote(C, "        if(Wosize_val(in) != sizeof(uint64_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint64_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint32_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint32_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter + sizeof(uint32_t));");
quote(C, "            (*out).value[counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint32_t);");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_64 && peer_arch == BIG_ENDIAN_32){");
quote(C, "        if(Wosize_val(in) != sizeof(uint32_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint32_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint64_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint64_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C,
      "            (*out).value[counter + sizeof(uint32_t)] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint64_t);");
quote(C, "    }");
quote(C, "");
quote(C,
      "    if(my_arch == LITTLE_ENDIAN_64 && peer_arch == LITTLE_ENDIAN_32){");
quote(C, "        if(Wosize_val(in) != sizeof(uint32_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint32_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint64_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint64_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C, "            (*out).value[counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint64_t);");
quote(C, "    }");
quote(C, "");
quote(C,
      "    if(my_arch == LITTLE_ENDIAN_64 && peer_arch == LITTLE_ENDIAN_64){");
quote(C, "        if(Wosize_val(in) != sizeof(uint64_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint64_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint64_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint64_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint64_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C, "            (*out).value[counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint64_t);");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_32 && peer_arch == BIG_ENDIAN_32){");
quote(C, "        if(Wosize_val(in) != sizeof(uint32_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint32_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint32_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint32_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C, "            (*out).value[counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint32_t);");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_64 && peer_arch == BIG_ENDIAN_64){");
quote(C, "        if(Wosize_val(in) != sizeof(uint64_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint64_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint64_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint64_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint64_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C, "            (*out).value[counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint64_t);");
quote(C, "");
quote(C, "    }");
quote(C, "    if(my_arch == LITTLE_ENDIAN_32 && peer_arch == BIG_ENDIAN_32){");
quote(C, "        if(Wosize_val(in) != sizeof(uint32_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint32_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint32_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint32_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C,
      "            (*out).value[(sizeof(uint32_t) -1 ) - counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint32_t);");
quote(C, "");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_32 && peer_arch == LITTLE_ENDIAN_32){");
quote(C, "        if(Wosize_val(in) != sizeof(uint32_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint32_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint32_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint32_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C,
      "            (*out).value[(sizeof(uint32_t) -1 ) - counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint32_t);");
quote(C, "    }");
quote(C, "    if(my_arch == LITTLE_ENDIAN_64 && peer_arch == BIG_ENDIAN_64){");
quote(C, "        if(Wosize_val(in) != sizeof(uint64_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint64_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint64_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint64_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint64_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C,
      "            (*out).value[(sizeof(uint64_t) -1 ) - counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint64_t);");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_64 && peer_arch == LITTLE_ENDIAN_64){");
quote(C, "        if(Wosize_val(in) != sizeof(uint64_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint64_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint64_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint64_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint64_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C,
      "            (*out).value[(sizeof(uint64_t) -1 ) - counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint64_t);");
quote(C, "    }");
quote(C, "    if(my_arch == LITTLE_ENDIAN_64 && peer_arch == BIG_ENDIAN_32){");
quote(C, "        if(Wosize_val(in) != sizeof(uint32_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint32_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint64_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint64_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C,
      "            (*out).value[(sizeof(uint32_t) -1 ) - counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint64_t);");
quote(C, "");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_32 && peer_arch == LITTLE_ENDIAN_64){");
quote(C, "        if(Wosize_val(in) != sizeof(uint64_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint64_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint32_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint32_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C,
      "            (*out).value[(sizeof(uint32_t) -1 ) - counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint32_t);");
quote(C, "    }");
quote(C, "    if(my_arch == LITTLE_ENDIAN_32 && peer_arch == BIG_ENDIAN_64){");
quote(C, "        if(Wosize_val(in) != sizeof(uint64_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint64_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint32_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint32_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter + sizeof(uint32_t));");
quote(C,
      "            (*out).value[(sizeof(uint32_t) -1 ) - counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint32_t);");
quote(C, "");
quote(C, "    }");
quote(C, "    if(my_arch == BIG_ENDIAN_64 && peer_arch == LITTLE_ENDIAN_32){");
quote(C, "        if(Wosize_val(in) != sizeof(uint32_t)){");
quote(C, "#ifdef DEBUG");
quote(C,
      "            fprintf(stderr, \"Something went wrong with the endianness transformation : got %lu instead of %lu\\n\", Wosize_val(in), sizeof(uint32_t));");
quote(C, "#endif");
quote(C, "            return -1;");
quote(C, "        }");
quote(C, "        (*out).value = camlidl_malloc(sizeof(uint64_t), _ctx);");
quote(C, "        memset((*out).value, 0, sizeof(uint64_t));");
quote(C, "        for(counter = 0; counter < sizeof(uint32_t); counter++) {");
quote(C, "            vtmp = Field(in, counter);");
quote(C,
      "            (*out).value[(sizeof(uint64_t) -1 ) - counter] = Int_val(vtmp);");
quote(C, "        }");
quote(C, "        (*out).value_len = sizeof(uint64_t);");
quote(C, "    }");
quote(C, "    return 0;");
quote(C, "}");
quote(C, "#endif");

quote(ml, "let c_Daemonize = fun param -> mL_CK_C_Daemonize param");
quote(ml, "let c_SetupArch = fun arch -> mL_CK_C_SetupArch arch");
quote(ml, "let c_LoadModule = fun path -> mL_CK_C_LoadModule path");
quote(ml, "let c_Initialize () =  mL_CK_C_Initialize ()");
quote(ml, "let c_GetInfo () = mL_CK_C_GetInfo ()");
quote(ml,
      "let c_GetSlotList = fun token_present count -> mL_CK_C_GetSlotList token_present count");
quote(ml,
      "let c_GetSlotInfo = fun ckslotidt_ -> mL_CK_C_GetSlotInfo ckslotidt_");
quote(ml,
      "let c_GetTokenInfo = fun ckslotidt_ -> mL_CK_C_GetTokenInfo ckslotidt_");
quote(ml,
      "let c_WaitForSlotEvent = fun ckflagst_ -> mL_CK_C_WaitForSlotEvent ckflagst_ ");
quote(ml,
      "let c_GetMechanismList = fun ckslotidt_ count -> mL_CK_C_GetMechanismList ckslotidt_ count ");
quote(ml,
      "let c_GetMechanismInfo = fun ckslotidt_ ckmechanismtypet_ -> mL_CK_C_GetMechanismInfo ckslotidt_ ckmechanismtypet_ ");
quote(ml,
      "let c_InitToken = fun ckslotidt_  so_pin label -> mL_CK_C_InitToken ckslotidt_  so_pin label ");
quote(ml,
      "let c_InitPIN = fun cksessionhandlet_ pin -> mL_CK_C_InitPIN cksessionhandlet_ pin ");
quote(ml,
      "let c_SetPIN = fun cksessionhandlet_ old_pin  new_pin -> mL_CK_C_SetPIN cksessionhandlet_ old_pin  new_pin ");
quote(ml,
      "let c_OpenSession = fun ckslotid_ ckflagst_ -> mL_CK_C_OpenSession ckslotid_ ckflagst_");
quote(ml,
      "let c_CloseSession = fun cksessionhandlet_ -> mL_CK_C_CloseSession cksessionhandlet_ ");
quote(ml,
      "let c_CloseAllSessions = fun ckslotidt_ -> mL_CK_C_CloseAllSessions ckslotidt_ ");
quote(ml,
      "let c_GetSessionInfo = fun cksessionhandlet_ -> mL_CK_C_GetSessionInfo cksessionhandlet_ ");
quote(ml,
      "let c_GetOperationState = fun cksessionhandlet_ -> mL_CK_C_GetOperationState cksessionhandlet_ ");
quote(ml,
      "let c_SetOperationState = fun cksessionhandlet_ state encryption_handle authentication_handle -> mL_CK_C_SetOperationState cksessionhandlet_ state encryption_handle authentication_handle");
quote(ml,
      "let c_Login = fun cksessionhandlet_ ckusertypet_ pin -> mL_CK_C_Login cksessionhandlet_ ckusertypet_ pin ");
quote(ml,
      "let c_Logout = fun cksessionhandlet -> mL_CK_C_Logout cksessionhandlet ");
quote(ml, "let c_Finalize () = mL_CK_C_Finalize ()");
quote(ml,
      "let c_CreateObject = fun cksessionhandlet_ ckattributearray_  -> mL_CK_C_CreateObject cksessionhandlet_ ckattributearray_ ");
quote(ml,
      "let c_CopyObject = fun cksessionhandlet_ ckobjecthandlet_ ckattributearray_  -> mL_CK_C_CopyObject cksessionhandlet_ ckobjecthandlet_ ckattributearray_");
quote(ml,
      "let c_DestroyObject = fun cksessionhandlet_ ckobjecthandlet_ -> mL_CK_C_DestroyObject cksessionhandlet_ ckobjecthandlet_ ");
quote(ml,
      "let c_GetObjectSize = fun cksessionhandlet_ ckobjecthandlet_  -> mL_CK_C_GetObjectSize cksessionhandlet_ ckobjecthandlet_  ");
quote(ml,
      "let c_GetAttributeValue = fun cksessionhandlet_ ckobjecthandlet_ ckattributearray_ -> mL_CK_C_GetAttributeValue cksessionhandlet_ ckobjecthandlet_ ckattributearray_ ");
quote(ml,
      "let c_SetAttributeValue = fun cksessionhandlet_ ckobjecthandlet_ ckattributearray_ -> mL_CK_C_SetAttributeValue cksessionhandlet_ ckobjecthandlet_ ckattributearray_ ");
quote(ml,
      "let c_FindObjectsInit = fun cksessionhandlet_ ckattributearray_ -> mL_CK_C_FindObjectsInit cksessionhandlet_ ckattributearray_ ");
quote(ml,
      "let c_FindObjects = fun cksessionhandlet_ count -> mL_CK_C_FindObjects cksessionhandlet_ count ");
quote(ml,
      "let c_FindObjectsFinal = fun cksessionhandlet_ -> mL_CK_C_FindObjectsFinal cksessionhandlet_ ");
quote(ml,
      "let c_EncryptInit = fun cksessionhandlet_ ckmechanism_ ckobjecthandlet_ -> mL_CK_C_EncryptInit cksessionhandlet_ ckmechanism_ ckobjecthandlet_ ");
quote(ml,
      "let c_Encrypt = fun cksessionhandlet_ data  -> mL_CK_C_Encrypt cksessionhandlet_ data  ");
quote(ml,
      "let c_EncryptUpdate = fun cksessionhandlet_ data  -> mL_CK_C_EncryptUpdate cksessionhandlet_ data  ");
quote(ml,
      "let c_EncryptFinal = fun cksessionhandlet_  -> mL_CK_C_EncryptFinal cksessionhandlet_ ");
quote(ml,
      "let c_DecryptInit = fun cksessionhandlet_ ckmechanism_ ckobjecthandlet_ -> mL_CK_C_DecryptInit cksessionhandlet_ ckmechanism_ ckobjecthandlet_");
quote(ml,
      "let c_Decrypt = fun cksessionhandlet_ data  -> mL_CK_C_Decrypt cksessionhandlet_ data ");
quote(ml,
      "let c_DecryptUpdate = fun cksessionhandlet_ data  -> mL_CK_C_DecryptUpdate cksessionhandlet_ data ");
quote(ml,
      "let c_DecryptFinal = fun cksessionhandlet_ -> mL_CK_C_DecryptFinal cksessionhandlet_ ");
quote(ml,
      "let c_DigestInit = fun cksessionhandlet_ ckmechanism_  -> mL_CK_C_DigestInit cksessionhandlet_ ckmechanism_  ");
quote(ml,
      "let c_Digest = fun cksessionhandlet_ data   -> mL_CK_C_Digest cksessionhandlet_ data  ");
quote(ml,
      "let c_DigestUpdate = fun cksessionhandlet_ data   -> mL_CK_C_DigestUpdate cksessionhandlet_ data  ");
quote(ml,
      "let c_DigestKey = fun cksessionhandlet_ ckobjecthandlet_  -> mL_CK_C_DigestKey cksessionhandlet_ ckobjecthandlet_  ");
quote(ml,
      "let c_DigestFinal = fun cksessionhandlet -> mL_CK_C_DigestFinal cksessionhandlet ");
quote(ml,
      "let c_SignInit = fun cksessionhandlet_ ckmechanism_ ckobjecthandlet_ -> mL_CK_C_SignInit cksessionhandlet_ ckmechanism_ ckobjecthandlet_ ");
quote(ml,
      "let c_SignRecoverInit = fun cksessionhandlet_ ckmechanism_ ckobjecthandlet_ -> mL_CK_C_SignRecoverInit cksessionhandlet_ ckmechanism_ ckobjecthandlet_ ");
quote(ml,
      "let c_Sign = fun cksessionhandlet_ data  -> mL_CK_C_Sign cksessionhandlet_ data ");
quote(ml,
      "let c_SignRecover = fun cksessionhandlet_ data  -> mL_CK_C_SignRecover cksessionhandlet_ data ");
quote(ml,
      "let c_SignUpdate = fun cksessionhandlet_ data  -> mL_CK_C_SignUpdate cksessionhandlet_ data ");
quote(ml,
      "let c_SignFinal = fun  cksessionhandlet_ -> mL_CK_C_SignFinal  cksessionhandlet_ ");
quote(ml,
      "let c_VerifyInit = fun cksessionhandlet_ ckmechanism_ ckobjecthandlet_ -> mL_CK_C_VerifyInit cksessionhandlet_ ckmechanism_ ckobjecthandlet_ ");
quote(ml,
      "let c_VerifyRecoverInit = fun cksessionhandlet_ ckmechanism_ ckobjecthandlet_ -> mL_CK_C_VerifyRecoverInit cksessionhandlet_ ckmechanism_ ckobjecthandlet_ ");
quote(ml,
      "let c_Verify = fun cksessionhandlet_ data signed_data -> mL_CK_C_Verify cksessionhandlet_ data signed_data ");
quote(ml,
      "let c_VerifyRecover = fun cksessionhandlet_ data  -> mL_CK_C_VerifyRecover cksessionhandlet_ data  ");
quote(ml,
      "let c_VerifyUpdate = fun cksessionhandlet_ data  -> mL_CK_C_VerifyUpdate cksessionhandlet_ data  ");
quote(ml,
      "let c_VerifyFinal = fun cksessionhandlet_ data  -> mL_CK_C_VerifyFinal cksessionhandlet_ data  ");
quote(ml,
      "let c_DigestEncryptUpdate = fun cksessionhandlet_ data  -> mL_CK_C_DigestEncryptUpdate cksessionhandlet_ data");
quote(ml,
      "let c_DecryptDigestUpdate = fun cksessionhandlet_ data -> mL_CK_C_DecryptDigestUpdate cksessionhandlet_ data ");
quote(ml,
      "let c_SignEncryptUpdate = fun cksessionhandlet_ data  -> mL_CK_C_SignEncryptUpdate cksessionhandlet_ data");
quote(ml,
      "let c_DecryptVerifyUpdate = fun cksessionhandlet_ data -> mL_CK_C_DecryptVerifyUpdate cksessionhandlet_ data ");
quote(ml,
      "let c_GenerateKey = fun cksessionhandlet_ ckmechanism_ ckattributearray_ -> mL_CK_C_GenerateKey cksessionhandlet_ ckmechanism_ ckattributearray_ ");
quote(ml,
      "let c_GenerateKeyPair = fun cksessionhandlet_ ckmechanism_ pub_attributes priv_attributes -> mL_CK_C_GenerateKeyPair cksessionhandlet_ ckmechanism_ pub_attributes priv_attributes");
quote(ml,
      "let c_WrapKey = fun cksessionhandlet_ ckmechanism_ wrapping_handle wrapped_handle  -> mL_CK_C_WrapKey cksessionhandlet_ ckmechanism_ wrapping_handle wrapped_handle ");
quote(ml,
      "let c_UnwrapKey = fun cksessionhandlet_ ckmechanism_ unwrapping_handle wrapped_key ckattributearray_ -> mL_CK_C_UnwrapKey cksessionhandlet_ ckmechanism_ unwrapping_handle wrapped_key ckattributearray_ ");
quote(ml,
      "let c_DeriveKey = fun cksessionhandlet_ ckmechanism_ initial_key_handle ckattributearray_ -> mL_CK_C_DeriveKey cksessionhandlet_ ckmechanism_ initial_key_handle ckattributearray_ ");
quote(ml,
      "let c_SeedRandom = fun cksessionhandlet_ seed -> mL_CK_C_SeedRandom cksessionhandlet_ seed ");
quote(ml,
      "let c_GenerateRandom = fun cksessionhandlet_ count -> mL_CK_C_GenerateRandom cksessionhandlet_ count");
quote(ml,
      "let c_GetFunctionStatus = fun cksessionhandlet_  -> mL_CK_C_GetFunctionStatus cksessionhandlet_  ");
quote(ml,
      "let c_CancelFunction = fun cksessionhandlet_  -> mL_CK_C_CancelFunction cksessionhandlet_  ");

quote(mli, "val c_Daemonize : char array -> ck_rv_t");
quote(mli, "val c_SetupArch : nativeint -> ck_rv_t");
quote(mli, "val c_LoadModule : char array -> ck_rv_t");
quote(mli, "val c_Initialize : unit -> ck_rv_t");
quote(mli, "val c_GetInfo : unit -> ck_rv_t * ck_info");
quote(mli,
      "val c_GetSlotList : nativeint -> nativeint -> ck_rv_t * ck_slot_id_t array * nativeint");
quote(mli, "val c_GetSlotInfo : ck_slot_id_t -> ck_rv_t * ck_slot_info");
quote(mli, "val c_GetTokenInfo : ck_slot_id_t -> ck_rv_t * ck_token_info");
quote(mli, "val c_WaitForSlotEvent : ck_flags_t -> ck_rv_t * ck_slot_id_t");
quote(mli,
      "val c_GetMechanismList : ck_slot_id_t -> nativeint -> ck_rv_t * ck_mechanism_type_t array * nativeint");
quote(mli,
      "val c_GetMechanismInfo : ck_slot_id_t -> ck_mechanism_type_t -> ck_rv_t * ck_mechanism_info");
quote(mli,
      "val c_InitToken : ck_slot_id_t -> char array -> char array -> ck_rv_t");
quote(mli, "val c_InitPIN : ck_session_handle_t -> char array -> ck_rv_t");
quote(mli,
      "val c_SetPIN : ck_session_handle_t -> char array -> char array -> ck_rv_t");
quote(mli,
      "val c_OpenSession : ck_slot_id_t -> ck_flags_t -> ck_rv_t * ck_session_handle_t");
quote(mli, "val c_CloseSession : ck_session_handle_t -> ck_rv_t");
quote(mli, "val c_CloseAllSessions : ck_slot_id_t -> ck_rv_t");
quote(mli,
      "val c_GetSessionInfo : ck_session_handle_t -> ck_rv_t * ck_session_info");
quote(mli,
      "val c_GetOperationState : ck_session_handle_t -> ck_rv_t * char array");
quote(mli,
      "val c_SetOperationState : ck_session_handle_t -> char array -> ck_object_handle_t -> ck_object_handle_t -> ck_rv_t");
quote(mli,
      "val c_Login : ck_session_handle_t -> ck_user_type_t -> char array -> ck_rv_t");
quote(mli, "val c_Logout : ck_session_handle_t -> ck_rv_t");
quote(mli, "val c_Finalize : unit -> ck_rv_t");
quote(mli,
      "val c_CreateObject : ck_session_handle_t -> ck_attribute array -> ck_rv_t * ck_object_handle_t");
quote(mli,
      "val c_CopyObject : ck_session_handle_t -> ck_object_handle_t -> ck_attribute array -> ck_rv_t * ck_object_handle_t");
quote(mli,
      "val c_DestroyObject : ck_session_handle_t -> ck_object_handle_t -> ck_rv_t");
quote(mli,
      "val c_GetObjectSize : ck_session_handle_t -> ck_object_handle_t -> ck_rv_t * nativeint");
quote(mli,
      "val c_GetAttributeValue : ck_session_handle_t -> ck_object_handle_t -> ck_attribute array -> ck_rv_t * ck_attribute array");
quote(mli,
      "val c_SetAttributeValue : ck_session_handle_t -> ck_object_handle_t -> ck_attribute array -> ck_rv_t");
quote(mli,
      "val c_FindObjectsInit : ck_session_handle_t -> ck_attribute array -> ck_rv_t");
quote(mli,
      "val c_FindObjects : ck_session_handle_t -> nativeint -> ck_rv_t * ck_object_handle_t array * nativeint");
quote(mli, "val c_FindObjectsFinal : ck_session_handle_t -> ck_rv_t");
quote(mli,
      "val c_EncryptInit : ck_session_handle_t -> ck_mechanism -> ck_object_handle_t -> ck_rv_t");
quote(mli,
      "val c_Encrypt : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli,
      "val c_EncryptUpdate : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli, "val c_EncryptFinal : ck_session_handle_t -> ck_rv_t * char array");
quote(mli,
      "val c_DecryptInit : ck_session_handle_t -> ck_mechanism -> ck_object_handle_t -> ck_rv_t");
quote(mli,
      "val c_Decrypt : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli,
      "val c_DecryptUpdate : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli, "val c_DecryptFinal : ck_session_handle_t -> ck_rv_t * char array");
quote(mli, "val c_DigestInit : ck_session_handle_t -> ck_mechanism -> ck_rv_t");
quote(mli,
      "val c_Digest : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli, "val c_DigestUpdate : ck_session_handle_t -> char array -> ck_rv_t");
quote(mli,
      "val c_DigestKey : ck_session_handle_t -> ck_object_handle_t -> ck_rv_t");
quote(mli, "val c_DigestFinal : ck_session_handle_t -> ck_rv_t * char array");
quote(mli,
      "val c_SignInit : ck_session_handle_t -> ck_mechanism -> ck_object_handle_t -> ck_rv_t");
quote(mli,
      "val c_SignRecoverInit : ck_session_handle_t -> ck_mechanism -> ck_object_handle_t -> ck_rv_t");
quote(mli,
      "val c_Sign : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli,
      "val c_SignRecover : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli, "val c_SignUpdate : ck_session_handle_t -> char array -> ck_rv_t");
quote(mli, "val c_SignFinal : ck_session_handle_t -> ck_rv_t * char array");
quote(mli,
      "val c_VerifyInit : ck_session_handle_t -> ck_mechanism -> ck_object_handle_t -> ck_rv_t");
quote(mli,
      "val c_VerifyRecoverInit : ck_session_handle_t -> ck_mechanism -> ck_object_handle_t -> ck_rv_t");
quote(mli,
      "val c_Verify : ck_session_handle_t -> char array -> char array -> ck_rv_t");
quote(mli,
      "val c_VerifyRecover : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli, "val c_VerifyUpdate : ck_session_handle_t -> char array -> ck_rv_t");
quote(mli, "val c_VerifyFinal : ck_session_handle_t -> char array -> ck_rv_t");
quote(mli,
      "val c_DigestEncryptUpdate : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli,
      "val c_DecryptDigestUpdate : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli,
      "val c_SignEncryptUpdate : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli,
      "val c_DecryptVerifyUpdate : ck_session_handle_t -> char array -> ck_rv_t * char array");
quote(mli,
      "val c_GenerateKey : ck_session_handle_t -> ck_mechanism -> ck_attribute array -> ck_rv_t * ck_object_handle_t");
quote(mli,
      "val c_GenerateKeyPair : ck_session_handle_t -> ck_mechanism -> ck_attribute array -> ck_attribute array -> ck_rv_t * ck_object_handle_t * ck_object_handle_t");
quote(mli,
      "val c_WrapKey : ck_session_handle_t -> ck_mechanism -> ck_object_handle_t -> ck_object_handle_t -> ck_rv_t * char array");
quote(mli,
      "val c_UnwrapKey : ck_session_handle_t -> ck_mechanism -> ck_object_handle_t -> char array -> ck_attribute array -> ck_rv_t * ck_object_handle_t");
quote(mli,
      "val c_DeriveKey : ck_session_handle_t -> ck_mechanism -> ck_object_handle_t -> ck_attribute array -> ck_rv_t * ck_object_handle_t");
quote(mli, "val c_SeedRandom : ck_session_handle_t -> char array -> ck_rv_t");
quote(mli,
      "val c_GenerateRandom : ck_session_handle_t -> nativeint -> ck_rv_t * char array");
quote(mli, "val c_GetFunctionStatus : ck_session_handle_t -> ck_rv_t");
quote(mli, "val c_CancelFunction : ck_session_handle_t -> ck_rv_t");
